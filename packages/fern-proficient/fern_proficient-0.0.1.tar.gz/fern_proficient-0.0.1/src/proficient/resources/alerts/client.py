# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.not_found_error import NotFoundError
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.alert_response_schema import AlertResponseSchema
from ...types.alert_stats_by_date import AlertStatsByDate
from ...types.alert_status import AlertStatus
from ...types.alert_status_reason import AlertStatusReason
from ...types.detailed_alert_schema_with_comment import DetailedAlertSchemaWithComment
from ...types.get_all_api_v_2_alerts_get_response import GetAllApiV2AlertsGetResponse
from ...types.get_filter_api_v_2_alerts_filter_name_get_response import GetFilterApiV2AlertsFilterNameGetResponse
from ...types.http_validation_error import HttpValidationError
from ...types.list_violated_data_assets_response import ListViolatedDataAssetsResponse
from ...types.list_violated_objects_response import ListViolatedObjectsResponse
from ...types.open_alerts_aggregation import OpenAlertsAggregation
from ...types.policy_severity import PolicySeverity
from ...types.resolved_alert_source import ResolvedAlertSource

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AlertsClient:
    def __init__(self, *, environment: str, client_wrapper: SyncClientWrapper):
        self._environment = environment
        self._client_wrapper = client_wrapper

    def get_filter(
        self, name: str, *, values: typing.Optional[str] = None, filters: typing.Optional[str] = None
    ) -> GetFilterApiV2AlertsFilterNameGetResponse:
        """
        Get all available filtering options for filtering on alerts.

        Parameters:
            - name: str.

            - values: typing.Optional[str].

            - filters: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/filter/{name}"),
            params=remove_none_from_dict({"values": values, "filters": filters}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetFilterApiV2AlertsFilterNameGetResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_data_assets_by_alert(self, alert_id: str) -> ListViolatedDataAssetsResponse:
        """
        Gets all data assets of a corresponding alert which are related to the violation.

        Parameters:
            - alert_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{alert_id}/data-assets"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListViolatedDataAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_violated_objects_by_alert(
        self, alert_id: str, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> ListViolatedObjectsResponse:
        """
        Gets all objects of a corresponding alert which are related to the violation.

        This endpoint is only relevant to alerts which are triggered on assets of type `OBJECT_GROUP`.

        Parameters:
            - alert_id: str.

            - offset: typing.Optional[int].

            - limit: typing.Optional[int].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{alert_id}/violated_objects"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListViolatedObjectsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_violated_objects_csv_by_alert(self, alert_id: str) -> ListViolatedObjectsResponse:
        """
        Gets all objects of a corresponding alert which are related to the violation, in CSV format.

        This endpoint is only relevant to alerts which are triggered on assets of type `OBJECT_GROUP`.

        Parameters:
            - alert_id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{alert_id}/violated_objects_csv"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListViolatedObjectsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_alert(
        self,
        alert_id: str,
        *,
        status: AlertStatus,
        reason: AlertStatusReason,
        resolved_alert_source: typing.Optional[ResolvedAlertSource] = OMIT,
        transitioned_at: typing.Optional[str] = OMIT,
    ) -> AlertResponseSchema:
        """
        Transition the state of the alert (e.g. open or close the alert).

        Parameters:
            - alert_id: str.

            - status: AlertStatus.

            - reason: AlertStatusReason.

            - resolved_alert_source: typing.Optional[ResolvedAlertSource].

            - transitioned_at: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"status": status, "reason": reason}
        if resolved_alert_source is not OMIT:
            _request["resolved_alert_source"] = resolved_alert_source
        if transitioned_at is not OMIT:
            _request["transitioned_at"] = transitioned_at
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/transition/{alert_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AlertResponseSchema, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_trends(
        self,
        *,
        from_date: str,
        severity: typing.Union[typing.Optional[PolicySeverity], typing.List[PolicySeverity]],
        to_date: typing.Optional[str] = None,
        interval: typing.Optional[float] = None,
        connector_id: typing.Optional[int] = None,
    ) -> typing.List[AlertStatsByDate]:
        """
        Gets alert trend information: how many alerts were
        opened and resolved, between `from_date` and `to_date`.

        Parameters:
            - from_date: str.

            - severity: typing.Union[typing.Optional[PolicySeverity], typing.List[PolicySeverity]].

            - to_date: typing.Optional[str].

            - interval: typing.Optional[float].

            - connector_id: typing.Optional[int].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v2/alerts/trends"),
            params=remove_none_from_dict(
                {
                    "from_date": from_date,
                    "severity": severity,
                    "to_date": to_date,
                    "interval": interval,
                    "connector_id": connector_id,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[AlertStatsByDate], _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def alert_comment(
        self, alert_id: str, *, comment: typing.Optional[str] = OMIT, comment_id: typing.Optional[str] = OMIT
    ) -> typing.Any:
        """
        Add a comment on the alert.

        Parameters:
            - alert_id: str.

            - comment: typing.Optional[str]. <span style="white-space: nowrap">`<= 300 characters`</span>

            - comment_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if comment is not OMIT:
            _request["comment"] = comment
        if comment_id is not OMIT:
            _request["comment_id"] = comment_id
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/comment/{alert_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_open_alerts_aggregated(
        self, *, connector_id: typing.Optional[int] = None
    ) -> typing.List[OpenAlertsAggregation]:
        """
        Get a summary of the number of open alerts per severity.

        Parameters:
            - connector_id: typing.Optional[int].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v2/alerts/aggregation/open"),
            params=remove_none_from_dict({"connector_id": connector_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[OpenAlertsAggregation], _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, id: str) -> DetailedAlertSchemaWithComment:
        """
        Get information about a specific alert by ID.

        Parameters:
            - id: str.
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DetailedAlertSchemaWithComment, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_all(
        self,
        *,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        count_only: typing.Optional[bool] = None,
        group_by: typing.Optional[str] = None,
        sort_by: typing.Optional[str] = None,
        filters: typing.Optional[str] = None,
        with_entities: typing.Optional[str] = None,
    ) -> GetAllApiV2AlertsGetResponse:
        """
        List all alerts.

        Parameters:
            - offset: typing.Optional[int].

            - limit: typing.Optional[int].

            - count_only: typing.Optional[bool].

            - group_by: typing.Optional[str].

            - sort_by: typing.Optional[str].

            - filters: typing.Optional[str].

            - with_entities: typing.Optional[str].
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v2/alerts"),
            params=remove_none_from_dict(
                {
                    "offset": offset,
                    "limit": limit,
                    "count_only": count_only,
                    "group_by": group_by,
                    "sort_by": sort_by,
                    "filters": filters,
                    "with_entities": with_entities,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetAllApiV2AlertsGetResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAlertsClient:
    def __init__(self, *, environment: str, client_wrapper: AsyncClientWrapper):
        self._environment = environment
        self._client_wrapper = client_wrapper

    async def get_filter(
        self, name: str, *, values: typing.Optional[str] = None, filters: typing.Optional[str] = None
    ) -> GetFilterApiV2AlertsFilterNameGetResponse:
        """
        Get all available filtering options for filtering on alerts.

        Parameters:
            - name: str.

            - values: typing.Optional[str].

            - filters: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/filter/{name}"),
            params=remove_none_from_dict({"values": values, "filters": filters}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetFilterApiV2AlertsFilterNameGetResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_data_assets_by_alert(self, alert_id: str) -> ListViolatedDataAssetsResponse:
        """
        Gets all data assets of a corresponding alert which are related to the violation.

        Parameters:
            - alert_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{alert_id}/data-assets"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListViolatedDataAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_violated_objects_by_alert(
        self, alert_id: str, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> ListViolatedObjectsResponse:
        """
        Gets all objects of a corresponding alert which are related to the violation.

        This endpoint is only relevant to alerts which are triggered on assets of type `OBJECT_GROUP`.

        Parameters:
            - alert_id: str.

            - offset: typing.Optional[int].

            - limit: typing.Optional[int].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{alert_id}/violated_objects"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListViolatedObjectsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_violated_objects_csv_by_alert(self, alert_id: str) -> ListViolatedObjectsResponse:
        """
        Gets all objects of a corresponding alert which are related to the violation, in CSV format.

        This endpoint is only relevant to alerts which are triggered on assets of type `OBJECT_GROUP`.

        Parameters:
            - alert_id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{alert_id}/violated_objects_csv"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ListViolatedObjectsResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_alert(
        self,
        alert_id: str,
        *,
        status: AlertStatus,
        reason: AlertStatusReason,
        resolved_alert_source: typing.Optional[ResolvedAlertSource] = OMIT,
        transitioned_at: typing.Optional[str] = OMIT,
    ) -> AlertResponseSchema:
        """
        Transition the state of the alert (e.g. open or close the alert).

        Parameters:
            - alert_id: str.

            - status: AlertStatus.

            - reason: AlertStatusReason.

            - resolved_alert_source: typing.Optional[ResolvedAlertSource].

            - transitioned_at: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {"status": status, "reason": reason}
        if resolved_alert_source is not OMIT:
            _request["resolved_alert_source"] = resolved_alert_source
        if transitioned_at is not OMIT:
            _request["transitioned_at"] = transitioned_at
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/transition/{alert_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(AlertResponseSchema, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_trends(
        self,
        *,
        from_date: str,
        severity: typing.Union[typing.Optional[PolicySeverity], typing.List[PolicySeverity]],
        to_date: typing.Optional[str] = None,
        interval: typing.Optional[float] = None,
        connector_id: typing.Optional[int] = None,
    ) -> typing.List[AlertStatsByDate]:
        """
        Gets alert trend information: how many alerts were
        opened and resolved, between `from_date` and `to_date`.

        Parameters:
            - from_date: str.

            - severity: typing.Union[typing.Optional[PolicySeverity], typing.List[PolicySeverity]].

            - to_date: typing.Optional[str].

            - interval: typing.Optional[float].

            - connector_id: typing.Optional[int].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v2/alerts/trends"),
            params=remove_none_from_dict(
                {
                    "from_date": from_date,
                    "severity": severity,
                    "to_date": to_date,
                    "interval": interval,
                    "connector_id": connector_id,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[AlertStatsByDate], _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def alert_comment(
        self, alert_id: str, *, comment: typing.Optional[str] = OMIT, comment_id: typing.Optional[str] = OMIT
    ) -> typing.Any:
        """
        Add a comment on the alert.

        Parameters:
            - alert_id: str.

            - comment: typing.Optional[str]. <span style="white-space: nowrap">`<= 300 characters`</span>

            - comment_id: typing.Optional[str].
        """
        _request: typing.Dict[str, typing.Any] = {}
        if comment is not OMIT:
            _request["comment"] = comment
        if comment_id is not OMIT:
            _request["comment_id"] = comment_id
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/comment/{alert_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_open_alerts_aggregated(
        self, *, connector_id: typing.Optional[int] = None
    ) -> typing.List[OpenAlertsAggregation]:
        """
        Get a summary of the number of open alerts per severity.

        Parameters:
            - connector_id: typing.Optional[int].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v2/alerts/aggregation/open"),
            params=remove_none_from_dict({"connector_id": connector_id}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[OpenAlertsAggregation], _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, id: str) -> DetailedAlertSchemaWithComment:
        """
        Get information about a specific alert by ID.

        Parameters:
            - id: str.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v2/alerts/{id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DetailedAlertSchemaWithComment, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_all(
        self,
        *,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        count_only: typing.Optional[bool] = None,
        group_by: typing.Optional[str] = None,
        sort_by: typing.Optional[str] = None,
        filters: typing.Optional[str] = None,
        with_entities: typing.Optional[str] = None,
    ) -> GetAllApiV2AlertsGetResponse:
        """
        List all alerts.

        Parameters:
            - offset: typing.Optional[int].

            - limit: typing.Optional[int].

            - count_only: typing.Optional[bool].

            - group_by: typing.Optional[str].

            - sort_by: typing.Optional[str].

            - filters: typing.Optional[str].

            - with_entities: typing.Optional[str].
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v2/alerts"),
            params=remove_none_from_dict(
                {
                    "offset": offset,
                    "limit": limit,
                    "count_only": count_only,
                    "group_by": group_by,
                    "sort_by": sort_by,
                    "filters": filters,
                    "with_entities": with_entities,
                }
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(GetAllApiV2AlertsGetResponse, _response.json())  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
