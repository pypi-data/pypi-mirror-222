# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _vna_python
else:
    import _vna_python

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_SwigPyIterator

    def value(self):
        return _vna_python.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _vna_python.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _vna_python.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _vna_python.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _vna_python.SwigPyIterator_equal(self, x)

    def copy(self):
        return _vna_python.SwigPyIterator_copy(self)

    def next(self):
        return _vna_python.SwigPyIterator_next(self)

    def __next__(self):
        return _vna_python.SwigPyIterator___next__(self)

    def previous(self):
        return _vna_python.SwigPyIterator_previous(self)

    def advance(self, n):
        return _vna_python.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _vna_python.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _vna_python.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _vna_python.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _vna_python.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _vna_python.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _vna_python.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _vna_python:
_vna_python.SwigPyIterator_swigregister(SwigPyIterator)
DeviceType_PICO_VNA_108 = _vna_python.DeviceType_PICO_VNA_108
DeviceType_PICO_VNA_106 = _vna_python.DeviceType_PICO_VNA_106
DeviceType_ECAL = _vna_python.DeviceType_ECAL
DeviceType_NUM_SUPPORTED_DEVICES = _vna_python.DeviceType_NUM_SUPPORTED_DEVICES
ECalDeviceType_F_F = _vna_python.ECalDeviceType_F_F
ECalDeviceType_M_M = _vna_python.ECalDeviceType_M_M
ECalAdapterMode_NO_ADAPTER = _vna_python.ECalAdapterMode_NO_ADAPTER
ECalAdapterMode_ADAPTER_TO_PORT_1 = _vna_python.ECalAdapterMode_ADAPTER_TO_PORT_1
ECalAdapterMode_ADAPTER_TO_PORT_2 = _vna_python.ECalAdapterMode_ADAPTER_TO_PORT_2
TriggerAction_RUN = _vna_python.TriggerAction_RUN
r""" On a trigger event, the device performs an entire measurement"""
TriggerAction_NEXT_POINT = _vna_python.TriggerAction_NEXT_POINT
r""" On a trigger event, the device moves to the next point in the sweep"""
TriggerMode_FREE_RUN = _vna_python.TriggerMode_FREE_RUN
r""" The device does not wait for a trigger event before starting a measurement."""
TriggerMode_RISING_EDGE = _vna_python.TriggerMode_RISING_EDGE
r""" The sweep will start when a rising edge is sensed on the trigger port."""
TriggerMode_FALLING_EDGE = _vna_python.TriggerMode_FALLING_EDGE
r""" The sweep will start when a falling edge is sensed on the trigger port."""
TriggerMode_MANUAL = _vna_python.TriggerMode_MANUAL
r""" The sweep will start when `VnaDevice::trigger()` is called for the appropriate device."""
MeasurementMode_ALL_PARAMS = _vna_python.MeasurementMode_ALL_PARAMS
r""" Collect all parameters."""
MeasurementMode_FORWARD_PARAMS = _vna_python.MeasurementMode_FORWARD_PARAMS
r""" Collect only forward parameters (S21/S12)"""
ActiveMeasurements_ALL_PARAMS = _vna_python.ActiveMeasurements_ALL_PARAMS
r""" Collect all S-parameters. Default for UOSM and TOSM calibrations."""
ActiveMeasurements_S11_ONLY = _vna_python.ActiveMeasurements_S11_ONLY
r""" Collect only S11. Default for S11 calibrations."""
ActiveMeasurements_S21_ONLY = _vna_python.ActiveMeasurements_S21_ONLY
r""" Collect only 21. Default for S21 calibrations."""
ActiveMeasurements_S11_AND_S21 = _vna_python.ActiveMeasurements_S11_AND_S21
r""" Collect S11 and S21. Default for S11+S21 calibrations."""
SweepMode_NORMAL = _vna_python.SweepMode_NORMAL
SweepMode_CONTINUOUS_WAVE = _vna_python.SweepMode_CONTINUOUS_WAVE
CalibrationType_InsertableCalibration = _vna_python.CalibrationType_InsertableCalibration
CalibrationType_UnknownThruCalibration = _vna_python.CalibrationType_UnknownThruCalibration
CalibrationType_TrlCalibration = _vna_python.CalibrationType_TrlCalibration
CalibrationType_S11Calibration = _vna_python.CalibrationType_S11Calibration
CalibrationType_S21Calibration = _vna_python.CalibrationType_S21Calibration
CalibrationType_S11AndS21Calibration = _vna_python.CalibrationType_S11AndS21Calibration
CalibrationType_ECal2Port = _vna_python.CalibrationType_ECal2Port
CalibrationType_ECal1Port = _vna_python.CalibrationType_ECal1Port
CalibrationStageType_REFLECTION = _vna_python.CalibrationStageType_REFLECTION
CalibrationStageType_ISOLATION = _vna_python.CalibrationStageType_ISOLATION
CalibrationStageType_THROUGH = _vna_python.CalibrationStageType_THROUGH
CalibrationStageType_LINE = _vna_python.CalibrationStageType_LINE
CalibrationStageType_PORT_1 = _vna_python.CalibrationStageType_PORT_1
CalibrationStageType_PORT_2 = _vna_python.CalibrationStageType_PORT_2
CalibrationStandard_NONE = _vna_python.CalibrationStandard_NONE
CalibrationStandard_ISOLATION = _vna_python.CalibrationStandard_ISOLATION
CalibrationStandard_LINE_1 = _vna_python.CalibrationStandard_LINE_1
CalibrationStandard_LINE_2 = _vna_python.CalibrationStandard_LINE_2
CalibrationStandard_SHORT = _vna_python.CalibrationStandard_SHORT
CalibrationStandard_OPEN = _vna_python.CalibrationStandard_OPEN
CalibrationStandard_MATCH = _vna_python.CalibrationStandard_MATCH
CalibrationStandard_THROUGH = _vna_python.CalibrationStandard_THROUGH
ConnectorType_FEMALE = _vna_python.ConnectorType_FEMALE
ConnectorType_MALE = _vna_python.ConnectorType_MALE
MeasurementParameter_S11 = _vna_python.MeasurementParameter_S11
MeasurementParameter_S21 = _vna_python.MeasurementParameter_S21
MeasurementParameter_S12 = _vna_python.MeasurementParameter_S12
MeasurementParameter_S22 = _vna_python.MeasurementParameter_S22
DemoDeviceDut_LOW_PASS_FILTER = _vna_python.DemoDeviceDut_LOW_PASS_FILTER
r"""Demo device will replay data recorded from measurements of a low pass filter"""
DemoDeviceDut_BAND_PASS_FILTER = _vna_python.DemoDeviceDut_BAND_PASS_FILTER
r"""Demo device will replay data recorded from measurements of a band pass filter"""
DemoDeviceDut_ATTENUATOR = _vna_python.DemoDeviceDut_ATTENUATOR
r"""Demo device will replay data recorded from measurements of an attenuator"""
DemoDeviceDut_ANTENNA = _vna_python.DemoDeviceDut_ANTENNA
r"""Demo device will replay data recorded from measurements of an antenna (S11 only)"""
TimeDomainResponse_IMPULSE = _vna_python.TimeDomainResponse_IMPULSE
TimeDomainResponse_STEP = _vna_python.TimeDomainResponse_STEP
TimeDomainMode_MAGNITUDE_BAND_PASS = _vna_python.TimeDomainMode_MAGNITUDE_BAND_PASS
TimeDomainMode_REAL_BAND_PASS = _vna_python.TimeDomainMode_REAL_BAND_PASS
TimeDomainMode_LOW_PASS = _vna_python.TimeDomainMode_LOW_PASS
TimeDomainDCTermination_NONE = _vna_python.TimeDomainDCTermination_NONE
TimeDomainDCTermination_AUTOMATIC = _vna_python.TimeDomainDCTermination_AUTOMATIC
TimeDomainDCTermination_OPEN = _vna_python.TimeDomainDCTermination_OPEN
TimeDomainDCTermination_RESISTIVE = _vna_python.TimeDomainDCTermination_RESISTIVE
TimeDomainDCTermination_SHORT = _vna_python.TimeDomainDCTermination_SHORT
TimeDomainWindowFunction_RECTANGULAR = _vna_python.TimeDomainWindowFunction_RECTANGULAR
TimeDomainWindowFunction_HANNING = _vna_python.TimeDomainWindowFunction_HANNING
TimeDomainWindowFunction_KAISER_BESSEL = _vna_python.TimeDomainWindowFunction_KAISER_BESSEL
class DeviceInfo(object):
    r"""Describes the hardware properties of a VNA device."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    serial = property(_vna_python.DeviceInfo_serial_get, _vna_python.DeviceInfo_serial_set, doc=r""" A unique identifier for this specific unit.""")
    model = property(_vna_python.DeviceInfo_model_get, _vna_python.DeviceInfo_model_set, doc=r""" Identifies which device model this is.""")
    numPorts = property(_vna_python.DeviceInfo_numPorts_get, _vna_python.DeviceInfo_numPorts_set, doc=r""" How many ports the VNA has.""")
    minSweepFrequencyHz = property(_vna_python.DeviceInfo_minSweepFrequencyHz_get, _vna_python.DeviceInfo_minSweepFrequencyHz_set, doc=r""" The minimum frequency the device can sample, in Hz.""")
    maxSweepFrequencyHz = property(_vna_python.DeviceInfo_maxSweepFrequencyHz_get, _vna_python.DeviceInfo_maxSweepFrequencyHz_set, doc=r""" The maximum frequency the device can sample, in Hz""")
    embeddedSoftwareVersion = property(_vna_python.DeviceInfo_embeddedSoftwareVersion_get, _vna_python.DeviceInfo_embeddedSoftwareVersion_set, doc=r""" Device firmware version""")
    longSerial = property(_vna_python.DeviceInfo_longSerial_get, _vna_python.DeviceInfo_longSerial_set, doc=r""" Serial number with an added date code""")
    buildDate = property(_vna_python.DeviceInfo_buildDate_get, _vna_python.DeviceInfo_buildDate_set, doc=r""" Build date of the device""")

    def __init__(self):
        _vna_python.DeviceInfo_swiginit(self, _vna_python.new_DeviceInfo())
    __swig_destroy__ = _vna_python.delete_DeviceInfo

# Register DeviceInfo in _vna_python:
_vna_python.DeviceInfo_swigregister(DeviceInfo)
class ECalDeviceInfo(object):
    r"""Describes the hardware properties of an ECal device."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    serial = property(_vna_python.ECalDeviceInfo_serial_get, _vna_python.ECalDeviceInfo_serial_set, doc=r""" A unique identifier for this specific unit.""")
    type = property(_vna_python.ECalDeviceInfo_type_get, _vna_python.ECalDeviceInfo_type_set, doc=r""" Identifies which type of E-Cal unit this is.""")
    minFrequencyHz = property(_vna_python.ECalDeviceInfo_minFrequencyHz_get, _vna_python.ECalDeviceInfo_minFrequencyHz_set, doc=r""" The minimum frequency supported.""")
    maxFrequencyHz = property(_vna_python.ECalDeviceInfo_maxFrequencyHz_get, _vna_python.ECalDeviceInfo_maxFrequencyHz_set, doc=r""" The maximum frequency supported.""")
    embeddedSoftwareVersion = property(_vna_python.ECalDeviceInfo_embeddedSoftwareVersion_get, _vna_python.ECalDeviceInfo_embeddedSoftwareVersion_set, doc=r""" Device firmware version.""")
    longSerial = property(_vna_python.ECalDeviceInfo_longSerial_get, _vna_python.ECalDeviceInfo_longSerial_set, doc=r""" Serial number with an added date code.""")
    buildDate = property(_vna_python.ECalDeviceInfo_buildDate_get, _vna_python.ECalDeviceInfo_buildDate_set, doc=r""" Build date of the device.""")
    throughLengthMm = property(_vna_python.ECalDeviceInfo_throughLengthMm_get, _vna_python.ECalDeviceInfo_throughLengthMm_set, doc=r""" Length of the through connection (in mm)""")

    def __init__(self):
        _vna_python.ECalDeviceInfo_swiginit(self, _vna_python.new_ECalDeviceInfo())
    __swig_destroy__ = _vna_python.delete_ECalDeviceInfo

# Register ECalDeviceInfo in _vna_python:
_vna_python.ECalDeviceInfo_swigregister(ECalDeviceInfo)
class MeasurementPoint(object):
    r"""Represents a single point in a sweep."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    frequencyHz = property(_vna_python.MeasurementPoint_frequencyHz_get, _vna_python.MeasurementPoint_frequencyHz_set, doc=r""" Frequency to sample, in Hz.""")
    powerLeveldBm = property(_vna_python.MeasurementPoint_powerLeveldBm_get, _vna_python.MeasurementPoint_powerLeveldBm_set, doc=r""" Power level to measure at, in dBm.""")
    bandwidthHz = property(_vna_python.MeasurementPoint_bandwidthHz_get, _vna_python.MeasurementPoint_bandwidthHz_set, doc=r""" Bandwidth to measure at, in Hz.""")
    timeS = property(_vna_python.MeasurementPoint_timeS_get, _vna_python.MeasurementPoint_timeS_set, doc=r"""
    timeS.
    Only meaningful if the sweep is CW-mode, otherwise this is ignored (and does not need to be initialised).
    """)

    def __init__(self):
        _vna_python.MeasurementPoint_swiginit(self, _vna_python.new_MeasurementPoint())
    __swig_destroy__ = _vna_python.delete_MeasurementPoint

# Register MeasurementPoint in _vna_python:
_vna_python.MeasurementPoint_swigregister(MeasurementPoint)
class MeasuredPoint(object):
    r"""Represents a single measurement point (forward or reverse) assocaited with an SParameter sample."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ref = property(_vna_python.MeasuredPoint_ref_get, _vna_python.MeasuredPoint_ref_set, doc=r""" Reference""")
    meas = property(_vna_python.MeasuredPoint_meas_get, _vna_python.MeasuredPoint_meas_set, doc=r""" Measured.""")

    def __init__(self):
        _vna_python.MeasuredPoint_swiginit(self, _vna_python.new_MeasuredPoint())
    __swig_destroy__ = _vna_python.delete_MeasuredPoint

# Register MeasuredPoint in _vna_python:
_vna_python.MeasuredPoint_swigregister(MeasuredPoint)
class SParameterMeasurementPoint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    measurementMode = property(_vna_python.SParameterMeasurementPoint_measurementMode_get, _vna_python.SParameterMeasurementPoint_measurementMode_set, doc=r"""
    The measurement mode in use when this point was collected.
    Indicates which fields of this class actually contain data
    """)
    measurementPointIndex = property(_vna_python.SParameterMeasurementPoint_measurementPointIndex_get, _vna_python.SParameterMeasurementPoint_measurementPointIndex_set, doc=r""" Which point in the sweep is this?""")
    measurementFrequencyHz = property(_vna_python.SParameterMeasurementPoint_measurementFrequencyHz_get, _vna_python.SParameterMeasurementPoint_measurementFrequencyHz_set, doc=r""" Frequency the sample was collected at""")
    measurementPowerLeveldBm = property(_vna_python.SParameterMeasurementPoint_measurementPowerLeveldBm_get, _vna_python.SParameterMeasurementPoint_measurementPowerLeveldBm_set, doc=r""" The power level the sample was collected at.""")
    measurementBandwidthHz = property(_vna_python.SParameterMeasurementPoint_measurementBandwidthHz_get, _vna_python.SParameterMeasurementPoint_measurementBandwidthHz_set, doc=r""" The bandwidth of the sample.""")
    forward = property(_vna_python.SParameterMeasurementPoint_forward_get, _vna_python.SParameterMeasurementPoint_forward_set, doc=r""" The forward raw AB measurement.""")
    reverse = property(_vna_python.SParameterMeasurementPoint_reverse_get, _vna_python.SParameterMeasurementPoint_reverse_set, doc=r""" The reverse raw AB measurement.""")
    s11 = property(_vna_python.SParameterMeasurementPoint_s11_get, _vna_python.SParameterMeasurementPoint_s11_set, doc=r""" The sParameter value for s11""")
    s21 = property(_vna_python.SParameterMeasurementPoint_s21_get, _vna_python.SParameterMeasurementPoint_s21_set, doc=r""" The sParameter value for s21""")
    s12 = property(_vna_python.SParameterMeasurementPoint_s12_get, _vna_python.SParameterMeasurementPoint_s12_set, doc=r""" The sParameter value for s12""")
    s22 = property(_vna_python.SParameterMeasurementPoint_s22_get, _vna_python.SParameterMeasurementPoint_s22_set, doc=r""" The sParameter value for s22""")

    def __init__(self):
        _vna_python.SParameterMeasurementPoint_swiginit(self, _vna_python.new_SParameterMeasurementPoint())
    __swig_destroy__ = _vna_python.delete_SParameterMeasurementPoint

# Register SParameterMeasurementPoint in _vna_python:
_vna_python.SParameterMeasurementPoint_swigregister(SParameterMeasurementPoint)
class CalibrationMetadata(object):
    r"""Metadata for a calibration."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    uuid = property(_vna_python.CalibrationMetadata_uuid_get, _vna_python.CalibrationMetadata_uuid_set, doc=r""" A random string that uniquely identifies this calibration. Is a v4 UUID.""")
    dateTime = property(_vna_python.CalibrationMetadata_dateTime_get, _vna_python.CalibrationMetadata_dateTime_set, doc=r""" When the calibration was created.""")
    deviceSerial = property(_vna_python.CalibrationMetadata_deviceSerial_get, _vna_python.CalibrationMetadata_deviceSerial_set, doc=r""" The serial number of the device the calibration was created for.""")
    name = property(_vna_python.CalibrationMetadata_name_get, _vna_python.CalibrationMetadata_name_set, doc=r""" The user-defined name of the calibration.""")
    userDescription = property(_vna_python.CalibrationMetadata_userDescription_get, _vna_python.CalibrationMetadata_userDescription_set, doc=r""" The user-defined description provided for the calibration.""")
    type = property(_vna_python.CalibrationMetadata_type_get, _vna_python.CalibrationMetadata_type_set, doc=r""" Identifies the type of calibration.""")
    numPoints = property(_vna_python.CalibrationMetadata_numPoints_get, _vna_python.CalibrationMetadata_numPoints_set, doc=r""" The number of measurement points with which the calibration was performed.""")
    startFreqHz = property(_vna_python.CalibrationMetadata_startFreqHz_get, _vna_python.CalibrationMetadata_startFreqHz_set, doc=r""" The frequency of the lowest-frequency measurement point taken during the calibration.""")
    stopFreqHz = property(_vna_python.CalibrationMetadata_stopFreqHz_get, _vna_python.CalibrationMetadata_stopFreqHz_set, doc=r""" The frequency of the highest-frequency measurement point taken during the calibration.""")
    powerLevelDbm = property(_vna_python.CalibrationMetadata_powerLevelDbm_get, _vna_python.CalibrationMetadata_powerLevelDbm_set, doc=r""" The power level, in dBm, at which the calibration was performed.""")
    bandwidthHz = property(_vna_python.CalibrationMetadata_bandwidthHz_get, _vna_python.CalibrationMetadata_bandwidthHz_set, doc=r""" The bandwidth at which the calibration was performed, in Hertz.""")
    useEnhancedIsolation = property(_vna_python.CalibrationMetadata_useEnhancedIsolation_get, _vna_python.CalibrationMetadata_useEnhancedIsolation_set, doc=r""" Whether or not the calibration was performed with enhanced isolation enabled.""")

    def __init__(self):
        _vna_python.CalibrationMetadata_swiginit(self, _vna_python.new_CalibrationMetadata())
    __swig_destroy__ = _vna_python.delete_CalibrationMetadata

# Register CalibrationMetadata in _vna_python:
_vna_python.CalibrationMetadata_swigregister(CalibrationMetadata)
class CalibrationKitMetadata(object):
    r"""Metadata for a calibration kit."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    uuid = property(_vna_python.CalibrationKitMetadata_uuid_get, _vna_python.CalibrationKitMetadata_uuid_set, doc=r""" A random string that uniquely identifies this calibration. Is a v4 UUID.""")
    connectorType = property(_vna_python.CalibrationKitMetadata_connectorType_get, _vna_python.CalibrationKitMetadata_connectorType_set, doc=r""" Is the connector type male or female?""")
    trlReflectionStandard = property(_vna_python.CalibrationKitMetadata_trlReflectionStandard_get, _vna_python.CalibrationKitMetadata_trlReflectionStandard_set, doc=r""" If this is a TRL calibration kit, should the open or short standard be used?""")
    dateTime = property(_vna_python.CalibrationKitMetadata_dateTime_get, _vna_python.CalibrationKitMetadata_dateTime_set, doc=r""" When the calibration kit was created or imported.""")
    name = property(_vna_python.CalibrationKitMetadata_name_get, _vna_python.CalibrationKitMetadata_name_set, doc=r""" The user-defined name of the calibration kit.""")
    userDescription = property(_vna_python.CalibrationKitMetadata_userDescription_get, _vna_python.CalibrationKitMetadata_userDescription_set, doc=r""" The user-defined description provided for the calibration kit.""")

    def __init__(self):
        _vna_python.CalibrationKitMetadata_swiginit(self, _vna_python.new_CalibrationKitMetadata())
    __swig_destroy__ = _vna_python.delete_CalibrationKitMetadata

# Register CalibrationKitMetadata in _vna_python:
_vna_python.CalibrationKitMetadata_swigregister(CalibrationKitMetadata)
class Exception(Exception):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_Exception

    def __init__(self, *args):
        _vna_python.Exception_swiginit(self, _vna_python.new_Exception(*args))

# Register Exception in _vna_python:
_vna_python.Exception_swigregister(Exception)
class CommsError(Exception):
    r"""
    An error occurred while communicating with the device.

    This might occur because the device was disconnected or has become unresponsive.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_CommsError

    def __init__(self, *args):
        _vna_python.CommsError_swiginit(self, _vna_python.new_CommsError(*args))

# Register CommsError in _vna_python:
_vna_python.CommsError_swigregister(CommsError)
class DeviceDoesNotHaveACalibrationException(Exception):
    r""" When attempting to retrieve or use a calibration with a device that doesn't support it (like the demo device)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_DeviceDoesNotHaveACalibrationException

    def __init__(self, *args):
        _vna_python.DeviceDoesNotHaveACalibrationException_swiginit(self, _vna_python.new_DeviceDoesNotHaveACalibrationException(*args))

# Register DeviceDoesNotHaveACalibrationException in _vna_python:
_vna_python.DeviceDoesNotHaveACalibrationException_swigregister(DeviceDoesNotHaveACalibrationException)
class DeviceNotAvailableException(Exception):
    r""" The device has been claimed by another process."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_DeviceNotAvailableException

    def __init__(self, *args):
        _vna_python.DeviceNotAvailableException_swiginit(self, _vna_python.new_DeviceNotAvailableException(*args))

# Register DeviceNotAvailableException in _vna_python:
_vna_python.DeviceNotAvailableException_swigregister(DeviceNotAvailableException)
class DeviceNotFoundException(Exception):
    r"""
    When opening a device, no device matching the supplied model or serial number could
    be found connected to the computer.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_DeviceNotFoundException

    def __init__(self, *args):
        _vna_python.DeviceNotFoundException_swiginit(self, _vna_python.new_DeviceNotFoundException(*args))

# Register DeviceNotFoundException in _vna_python:
_vna_python.DeviceNotFoundException_swigregister(DeviceNotFoundException)
class DeviceNotRecognisedException(Exception):
    r""" The device model is not recognised. Either it is not a supported model, or it is broken."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_DeviceNotRecognisedException

    def __init__(self, *args):
        _vna_python.DeviceNotRecognisedException_swiginit(self, _vna_python.new_DeviceNotRecognisedException(*args))

# Register DeviceNotRecognisedException in _vna_python:
_vna_python.DeviceNotRecognisedException_swigregister(DeviceNotRecognisedException)
class DeviceInitialisingException(Exception):
    r""" The device is initialising. It cannot be opened yet."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_DeviceInitialisingException

    def __init__(self, *args):
        _vna_python.DeviceInitialisingException_swiginit(self, _vna_python.new_DeviceInitialisingException(*args))

# Register DeviceInitialisingException in _vna_python:
_vna_python.DeviceInitialisingException_swigregister(DeviceInitialisingException)
class DeviceOpenFailedException(Exception):
    r"""
    When opening a device, although a device matching the supplied model or serial was successfully found, it could
    not be opened.

    This may be caused because the device has already been opened by this application or another
    (and so cannot be opened again concurrently) or because the user does not have the required
    permissions to open the device.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_DeviceOpenFailedException

    def __init__(self, *args):
        _vna_python.DeviceOpenFailedException_swiginit(self, _vna_python.new_DeviceOpenFailedException(*args))

# Register DeviceOpenFailedException in _vna_python:
_vna_python.DeviceOpenFailedException_swigregister(DeviceOpenFailedException)
class UpgradeRequiredException(Exception):
    r"""An upgrade needs to be purchased."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_UpgradeRequiredException

    def __init__(self, *args):
        _vna_python.UpgradeRequiredException_swiginit(self, _vna_python.new_UpgradeRequiredException(*args))

# Register UpgradeRequiredException in _vna_python:
_vna_python.UpgradeRequiredException_swigregister(UpgradeRequiredException)
class InvalidParameterException(Exception):
    r""" An invalid value was passed to the function."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_InvalidParameterException

    def __init__(self, *args):
        _vna_python.InvalidParameterException_swiginit(self, _vna_python.new_InvalidParameterException(*args))

# Register InvalidParameterException in _vna_python:
_vna_python.InvalidParameterException_swigregister(InvalidParameterException)
class MemoryAccessFailedException(Exception):
    r""" An attempt to access the device's memory failed for an unspecified reason."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_MemoryAccessFailedException

    def __init__(self, *args):
        _vna_python.MemoryAccessFailedException_swiginit(self, _vna_python.new_MemoryAccessFailedException(*args))

# Register MemoryAccessFailedException in _vna_python:
_vna_python.MemoryAccessFailedException_swigregister(MemoryAccessFailedException)
class NotAnECalDeviceException(Exception):
    r""" An attempt was made to open a device that isn't an E-Cal device, when an E-Cal device was expected"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_NotAnECalDeviceException

    def __init__(self, *args):
        _vna_python.NotAnECalDeviceException_swiginit(self, _vna_python.new_NotAnECalDeviceException(*args))

# Register NotAnECalDeviceException in _vna_python:
_vna_python.NotAnECalDeviceException_swigregister(NotAnECalDeviceException)
class NotAVnaDeviceException(Exception):
    r""" An attempt was made to open a device that isn't a VNA device, when a VNA device was expected"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_NotAVnaDeviceException

    def __init__(self, *args):
        _vna_python.NotAVnaDeviceException_swiginit(self, _vna_python.new_NotAVnaDeviceException(*args))

# Register NotAVnaDeviceException in _vna_python:
_vna_python.NotAVnaDeviceException_swigregister(NotAVnaDeviceException)
class OperationNotSupportedException(Exception):
    r""" The requested operation is not available on the device model attached to the PC."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_OperationNotSupportedException

    def __init__(self, *args):
        _vna_python.OperationNotSupportedException_swiginit(self, _vna_python.new_OperationNotSupportedException(*args))

# Register OperationNotSupportedException in _vna_python:
_vna_python.OperationNotSupportedException_swigregister(OperationNotSupportedException)
class ParameterDimensionalityException(Exception):
    r""" The dimensions of one or more parameters did not match the expected dimensions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_ParameterDimensionalityException

    def __init__(self, *args):
        _vna_python.ParameterDimensionalityException_swiginit(self, _vna_python.new_ParameterDimensionalityException(*args))

# Register ParameterDimensionalityException in _vna_python:
_vna_python.ParameterDimensionalityException_swigregister(ParameterDimensionalityException)
class ParseError(Exception):
    r""" The file you tried to load could not be parsed."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_ParseError

    def __init__(self, *args):
        _vna_python.ParseError_swiginit(self, _vna_python.new_ParseError(*args))

# Register ParseError in _vna_python:
_vna_python.ParseError_swigregister(ParseError)
class UnsupportedFileVersionException(Exception):
    r""" The version of the file format is not supported by this version of the software."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_UnsupportedFileVersionException

    def __init__(self, *args):
        _vna_python.UnsupportedFileVersionException_swiginit(self, _vna_python.new_UnsupportedFileVersionException(*args))

# Register UnsupportedFileVersionException in _vna_python:
_vna_python.UnsupportedFileVersionException_swigregister(UnsupportedFileVersionException)
class ActiveMeasurement(object):
    r"""Represents the ongoing execution of a single `MeasurementConfiguration` on the device."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2):
        _vna_python.ActiveMeasurement_swiginit(self, _vna_python.new_ActiveMeasurement(arg2))

    def hasMorePoints(self):
        r"""
        Determine whether there are more points available to read from the object using `getNextPoint()`.

        Not to be confused with `isFinished()`, which merely determines whether the measurement process has finished. If
        it has, the device is ready to do something else (and you may access all the data from the completed measurement).
        """
        return _vna_python.ActiveMeasurement_hasMorePoints(self)

    def getConfig(self):
        r""" Get the `MeasurementConfiguration` object originally used to define this sweep."""
        return _vna_python.ActiveMeasurement_getConfig(self)

    def getNextPoint(self):
        r"""
        Read the next data point from this sweep. Blocks until the data is available. This allows you to digest the data
        as it becomes available, or to manage your own memory.
        """
        return _vna_python.ActiveMeasurement_getNextPoint(self)

    def tryGetNextPoint(self, output):
        r"""
        If the next measurement point is already available, write it to `output`.
        :rtype: boolean
        :return: true iff a point was written out.
        """
        return _vna_python.ActiveMeasurement_tryGetNextPoint(self, output)

    def getAllPoints(self):
        r"""
        Wait for the sweep to finish, and return all remaining data at once.

        Equivalent to calling `getNextPoint()` in a loop. i.e.:

        ```{.cpp}
        std::vector<vna::SParameterMeasurementPoint> out;
        while (activeMeasurement.hasMorePoints()) {
            out.push_back(activeMeasurement.getNextPoint());
        }
        return out;
        ```
        """
        return _vna_python.ActiveMeasurement_getAllPoints(self)

    def abort(self):
        r"""
        Stop the sweep early.

        After stopping the sweep, you can still use `tryGetNextPoint()` to extract any remaining data from
        its buffer. This function blocks until the sweep has stopped and the device is ready to do other things.
        """
        return _vna_python.ActiveMeasurement_abort(self)
    __swig_destroy__ = _vna_python.delete_ActiveMeasurement

# Register ActiveMeasurement in _vna_python:
_vna_python.ActiveMeasurement_swigregister(ActiveMeasurement)
class Calibration(object):
    r"""
    Represents a calibration.

    This can be loaded into the VNA.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_Calibration

    def __init__(self, *args):
        _vna_python.Calibration_swiginit(self, _vna_python.new_Calibration(*args))

    @staticmethod
    def fromFile(path):
        r"""Load a calibration from a file."""
        return _vna_python.Calibration_fromFile(path)

    def toFile(self, path):
        r"""Save the calibration to a file."""
        return _vna_python.Calibration_toFile(self, path)

    def getMetadata(self):
        r"""Get the metadata for this calibration."""
        return _vna_python.Calibration_getMetadata(self)

# Register Calibration in _vna_python:
_vna_python.Calibration_swigregister(Calibration)
class Device(object):
    r"""Represents a connection to a VNA attached to this computer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def open(serial):
        r"""
        Open the instrument with the given serial number.

        Opening the same device twice is not allowed. An instrument may be closed by destructing the object the was created
        when it was opened (there is no explicit function for closing an instrument).

        For testing and product evaluation, serial numbers of the form `DEMOXXXX` (where XXXX is some integer)  may be
        used to request a simulated demonstration device. This provides a convenient way to test your code
        where no real device is available.
        """
        return _vna_python.Device_open(serial)

    @staticmethod
    def openAny():
        r"""
        Open any real instrument, but not the demo device.

        This is a convenient function to open the instrument where only one instrument is expected to be connected to
        the computer, and your program only requires one instrument.

        Since opening the same device twice is not allowed, it is not possible to use this function repeatedly to
        open multiple devices. To achieve that, you must get a list of available devices, and then open them by serial
        number.
        """
        return _vna_python.Device_openAny()

    @staticmethod
    def openDemo(*args):
        r"""
        Open the simulated demo device.

        This is equivalent to calling `open("DEMO000")`, except this function also allows the simulated DUT to be
        selected from a set of options.

        :type dut: int, optional
        :param dut: The device under test to demo.
        """
        return _vna_python.Device_openDemo(*args)
    __swig_destroy__ = _vna_python.delete_Device

    def __init__(self, arg2):
        _vna_python.Device_swiginit(self, _vna_python.new_Device(arg2))

    def getInfo(self):
        r"""
        Query properties of the connected instrument.

        The returned struct describes immutable, intrinsic properties of the attached instrument, such as model number
        and various hardware limits.
        """
        return _vna_python.Device_getInfo(self)

    def isIdle(self):
        r"""Returns true iff the device is not currently collecting measurements."""
        return _vna_python.Device_isIdle(self)

    def getTemperature(self):
        r"""
        Returns the instrument's internal temperature in degrees centigrade.
        This function is only available on the PicoVNA 108 instrument; on other instruments a
        vna::OperationNotSupportedException will be thrown.
        If the instrument is still initialising, NaN will be returned. In this case, call this function again later to
        obtain a temperature reading.
        """
        return _vna_python.Device_getTemperature(self)

    def loadFactoryCalibration(self):
        r""" Load the factory calibration."""
        return _vna_python.Device_loadFactoryCalibration(self)

    def applyCalibration(self, c):
        r""" Apply a calibration you loaded from a file."""
        return _vna_python.Device_applyCalibration(self, c)

    def applyCalibrationFromFile(self, path):
        r""" Load the calibration stored in the given file path."""
        return _vna_python.Device_applyCalibrationFromFile(self, path)

    def getMetadataForCurrentCalibration(self):
        r""" Returns metadata for the calibration that is currently applied"""
        return _vna_python.Device_getMetadataForCurrentCalibration(self)

    def pulseTriggerOutput(self):
        r""" Send a pulse through the VNA's trigger output port."""
        return _vna_python.Device_pulseTriggerOutput(self)

    def trigger(self):
        r"""
        If any sweep plans have been started with `startTriggeredSweep` in `MANUAL` mode, this function will
        activate them. Otherwise, this function is a no-op.
        """
        return _vna_python.Device_trigger(self)

    def performMeasurement(self, sweep):
        r"""
        Collect all the measurement points described by the given `vna::MeasurementConfiguration`, and return them in an
        `std::vector`.

        This function blocks until the device has collected all of the measurements, which could take any time from
        several microseconds to several minutes depending on the `vna::MeasurementConfiguration`

        If you wish to consume the data points incrementally as they become available (rather than blocking your
        application), use `startMeasurement()` to perform an asynchronous sweep.
        """
        return _vna_python.Device_performMeasurement(self, sweep)

    def startMeasurement(self, sweep):
        r"""
        Asynchronously start the sweep described by the given sweep plan. The sweep is handed to the sweep scheduler, and
        its data will become available soon. Use the functions of the `ActiveMeasurement` class to consume the data
        points incrementally as they become available.

        :rtype: :py:class:`ActiveMeasurement`
        :return: An ActiveMeasurement object representing the started sweep. The data for this sweep may be extracted from
            this object.
        """
        return _vna_python.Device_startMeasurement(self, sweep)

# Register Device in _vna_python:
_vna_python.Device_swigregister(Device)

def getConnectedDeviceInfo():
    r"""
    Get device information for all connected VNAs.

    This function can be used to choose between your VNAs based on their hardware properties, model number, etc.

    Since this function queries the hardware info of each device, it is much slower than `getConnectedDeviceSerials()`.
    This may be an issue if you have a large number of VNAs attached. To handle this problem:
    - Store a deviceSerial->info mapping somewhere in your application so you don't need to run this function more
      than once ever, and can simply `vna::open(theCorrectSerial)` when needed.
    - If you don't care about device properties and just want to load-balance (eg. if all your VNAs are identical),
      use `getConnectedDeviceSerials()` to list them and pass those IDs to `open()` according to your load-balance
      logic.

    The devices are returned ordered lexicographically by serial number.

     See also: open()
    """
    return _vna_python.getConnectedDeviceInfo()

def applySmoothing(*args):
    r"""
    *Overload 1:*

    Apply a smoothing algorithm to an array of complex numbers.

    This is intended to smooth S-parameters.

    :type dst: std::complex< double >
    :param dst: The output.
    :type src: std::complex< double >
    :param src: The input.
    :type count: int
    :param count: The size of the input and output.
    :type amount: float
    :param amount: The amount of smoothing. This is a number between 0.0 (least smoothing) and 1.0 (most smoothing). Note
                      that this is different from the UI, which ranges from 0.0 to 10.0.

    |

    *Overload 2:*

    Apply smoothing in-place
    :type buffer: std::vector< std::complex< double >,std::allocator< std::complex< double > > >
    :param buffer: The input, which is overwritten with the result.
    :type amount: float
    :param amount: The amount of smoothing. This is a number between 0.0 (least smoothing) and 1.0 (most smoothing). Note
                      that this is different from the UI, which ranges from 0.0 to 10.0.
    """
    return _vna_python.applySmoothing(*args)

def toLogMag(c):
    r"""Compute the log-magnitude of a measurement."""
    return _vna_python.toLogMag(c)

def toLinMag(c):
    r"""Compute the linear magnitude of a measurement."""
    return _vna_python.toLinMag(c)

def toPhaseRad(c):
    r"""Compute the phase of a measurement, in radians."""
    return _vna_python.toPhaseRad(c)

def toPhaseDeg(c):
    r"""Compute the phase of a measurement, in degrees."""
    return _vna_python.toPhaseDeg(c)

def toReal(c):
    r"""Extract the real part of a measured point."""
    return _vna_python.toReal(c)

def toImaginary(c):
    r"""Extract the imaginary part of a measured point."""
    return _vna_python.toImaginary(c)

def toVSWR(c):
    r"""Calculate the VSWR for a (reflection) measurement."""
    return _vna_python.toVSWR(c)
class MeasurementConfiguration(object):
    r"""Describes a sweep to be performed by the device."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _vna_python.delete_MeasurementConfiguration

    def __init__(self, *args):
        _vna_python.MeasurementConfiguration_swiginit(self, _vna_python.new_MeasurementConfiguration(*args))

    def getMode(self):
        return _vna_python.MeasurementConfiguration_getMode(self)

    def setMode(self, m):
        return _vna_python.MeasurementConfiguration_setMode(self, m)

    def getTriggerAction(self):
        return _vna_python.MeasurementConfiguration_getTriggerAction(self)

    def setTriggerAction(self, triggerAction):
        return _vna_python.MeasurementConfiguration_setTriggerAction(self, triggerAction)

    def getTriggerMode(self):
        return _vna_python.MeasurementConfiguration_getTriggerMode(self)

    def setTriggerMode(self, triggerMode):
        return _vna_python.MeasurementConfiguration_setTriggerMode(self, triggerMode)

    def getActiveMeasurements(self):
        r"""
        Which measurements do the calibration and DUT support? This is used to
        select the mode in de-embedding, based on what measurements are available.
        """
        return _vna_python.MeasurementConfiguration_getActiveMeasurements(self)

    def setActiveMeasurements(self, activeMeasurements):
        return _vna_python.MeasurementConfiguration_setActiveMeasurements(self, activeMeasurements)

    def clear(self):
        r""" Delete all measurement points;"""
        return _vna_python.MeasurementConfiguration_clear(self)

    def addPoint(self, p):
        r"""
        Add a point to the sweep. A sweep may be composed of an arbitrary set of points.

        It is not necessary for the frequency of each measurement point to exactly match the frequency of error terms
        in the loaded calibration. Adding points that do not exactly match the frequency of error terms in the loaded
        calibration will cause a new set of (interpolated) error terms to be generated so that a new calibration need
        not be carried out. Note that in order to obtain the best instrument capability a new calibration should be
        performed whenever the sweep parameters change.

        Point types (i.e: MeasurementPoint or CWMeasurementPoint) may not be mixed.
        """
        return _vna_python.MeasurementConfiguration_addPoint(self, p)

    def setAveraging(self, n):
        r"""
        If `n`>1, the device will be instructed to perform several sweeps and each measurement point returned by
        `performMeasurement` or by querying the `ActiveMeasurement` will be the average of the several measurements
        performed by the device. This averaging process will yield identical results to requesting several sweeps from
        the device (with averaging switched off) and computing the mean value for each measurement point in your code.

        Set `n`=1 to turn off averaging.

        :type n: int
        :param n: The number of samples to average over. Must not be zero.
        """
        return _vna_python.MeasurementConfiguration_setAveraging(self, n)

    def setPortOffset(self, port1Length, port2Length, dielectricConstant=1.0):
        r"""
        Apply reference plane offsetting in place.

        This is useful to correct for the connection of a device under test via a pair of cables of a known length. This
        happens before other de-embedding.

        :type port1Length: float
        :param port1Length: The length, in m, of the cable between port 1 and the device under test. Must be at least 0.
        :type port2Length: float
        :param port2Length: The length, in m, of the cable between port 2 and the device under test. Must be at least 0.
        :type dielectricConstant: float, optional
        :param dielectricConstant: The dielectric constant of the medium. This must be at least 1.0.
        """
        return _vna_python.MeasurementConfiguration_setPortOffset(self, port1Length, port2Length, dielectricConstant)

    def setDeEmbedPortNetworks(self, port, networks):
        r"""
        Set networks to de-embed from the measurement.

        :type port: int
        :param port: Port to put the network on.
        :type networks: std::vector< std::string,std::allocator< std::string > >
        :param networks: S2P files of networks on the port, starting with the network closest to the port and ending with
                            the network closest to the DUT.
        """
        return _vna_python.MeasurementConfiguration_setDeEmbedPortNetworks(self, port, networks)

    def getPoint(self, *args):
        return _vna_python.MeasurementConfiguration_getPoint(self, *args)

    def getPoints(self, *args):
        return _vna_python.MeasurementConfiguration_getPoints(self, *args)

    def getMeasurementFrequencies(self):
        r"""
        Extract the measurement frequencies from all points and return as a list of doubles.
        This is a handy shortcut for the case where you want to key something by frequency.
        """
        return _vna_python.MeasurementConfiguration_getMeasurementFrequencies(self)

    def numPoints(self):
        r""" Returns the number of points in the configuration."""
        return _vna_python.MeasurementConfiguration_numPoints(self)

    def addUniformFrequencySweep(self, numPoints, startFreqHz, stopFreqHz, powerLeveldBm, bandwidthHz):
        r"""
        Add some measurement points that are uniformly stepped through the frequency domain, with all other parameters
        fixed.

        :type numPoints: int
        :param numPoints: Number of points in the sweep.
        :type startFreqHz: float
        :param startFreqHz: The first frequency to sample.
        :type stopFreqHz: float
        :param stopFreqHz: The last frequency to sample.
        :type powerLeveldBm: float
        :param powerLeveldBm: The power level to use.
        :type bandwidthHz: float
        :param bandwidthHz: The bandwidth to use.
        """
        return _vna_python.MeasurementConfiguration_addUniformFrequencySweep(self, numPoints, startFreqHz, stopFreqHz, powerLeveldBm, bandwidthHz)

    def addUniformPowerSweep(self, numPoints, startPowerLeveldBm, stopPowerLeveldBm, frequencyHz, bandwidthHz):
        return _vna_python.MeasurementConfiguration_addUniformPowerSweep(self, numPoints, startPowerLeveldBm, stopPowerLeveldBm, frequencyHz, bandwidthHz)

# Register MeasurementConfiguration in _vna_python:
_vna_python.MeasurementConfiguration_swigregister(MeasurementConfiguration)
class TimeDomainOptions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    outputStartSeconds = property(_vna_python.TimeDomainOptions_outputStartSeconds_get, _vna_python.TimeDomainOptions_outputStartSeconds_set)
    outputEndSeconds = property(_vna_python.TimeDomainOptions_outputEndSeconds_get, _vna_python.TimeDomainOptions_outputEndSeconds_set)
    minOutputSampleRate = property(_vna_python.TimeDomainOptions_minOutputSampleRate_get, _vna_python.TimeDomainOptions_minOutputSampleRate_set)
    outputPaddingSamplesStart = property(_vna_python.TimeDomainOptions_outputPaddingSamplesStart_get, _vna_python.TimeDomainOptions_outputPaddingSamplesStart_set)
    outputPaddingSamplesEnd = property(_vna_python.TimeDomainOptions_outputPaddingSamplesEnd_get, _vna_python.TimeDomainOptions_outputPaddingSamplesEnd_set)
    response = property(_vna_python.TimeDomainOptions_response_get, _vna_python.TimeDomainOptions_response_set)
    mode = property(_vna_python.TimeDomainOptions_mode_get, _vna_python.TimeDomainOptions_mode_set)
    window = property(_vna_python.TimeDomainOptions_window_get, _vna_python.TimeDomainOptions_window_set)
    dcTermination = property(_vna_python.TimeDomainOptions_dcTermination_get, _vna_python.TimeDomainOptions_dcTermination_set)
    dcTerminationResistanceOhms = property(_vna_python.TimeDomainOptions_dcTerminationResistanceOhms_get, _vna_python.TimeDomainOptions_dcTerminationResistanceOhms_set, doc=r"""If resistive DC termination is in use, this is the resistance value.""")
    kbWindowOrder = property(_vna_python.TimeDomainOptions_kbWindowOrder_get, _vna_python.TimeDomainOptions_kbWindowOrder_set, doc=r"""
    If a Kaiser Bessel window function is in use, this value defines its window order.

    Otherwise, this field does nothing.
    """)

    def __init__(self):
        _vna_python.TimeDomainOptions_swiginit(self, _vna_python.new_TimeDomainOptions())
    __swig_destroy__ = _vna_python.delete_TimeDomainOptions

# Register TimeDomainOptions in _vna_python:
_vna_python.TimeDomainOptions_swigregister(TimeDomainOptions)
class TimeDomainSample(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time = property(_vna_python.TimeDomainSample_time_get, _vna_python.TimeDomainSample_time_set)
    sample = property(_vna_python.TimeDomainSample_sample_get, _vna_python.TimeDomainSample_sample_set)

    def __init__(self, *args):
        _vna_python.TimeDomainSample_swiginit(self, _vna_python.new_TimeDomainSample(*args))
    __swig_destroy__ = _vna_python.delete_TimeDomainSample

# Register TimeDomainSample in _vna_python:
_vna_python.TimeDomainSample_swigregister(TimeDomainSample)

def transform(*args):
    return _vna_python.transform(*args)
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _vna_python.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _vna_python.IntVector___nonzero__(self)

    def __bool__(self):
        return _vna_python.IntVector___bool__(self)

    def __len__(self):
        return _vna_python.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _vna_python.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _vna_python.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _vna_python.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _vna_python.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _vna_python.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _vna_python.IntVector___setitem__(self, *args)

    def pop(self):
        return _vna_python.IntVector_pop(self)

    def append(self, x):
        return _vna_python.IntVector_append(self, x)

    def empty(self):
        return _vna_python.IntVector_empty(self)

    def size(self):
        return _vna_python.IntVector_size(self)

    def swap(self, v):
        return _vna_python.IntVector_swap(self, v)

    def begin(self):
        return _vna_python.IntVector_begin(self)

    def end(self):
        return _vna_python.IntVector_end(self)

    def rbegin(self):
        return _vna_python.IntVector_rbegin(self)

    def rend(self):
        return _vna_python.IntVector_rend(self)

    def clear(self):
        return _vna_python.IntVector_clear(self)

    def get_allocator(self):
        return _vna_python.IntVector_get_allocator(self)

    def pop_back(self):
        return _vna_python.IntVector_pop_back(self)

    def erase(self, *args):
        return _vna_python.IntVector_erase(self, *args)

    def __init__(self, *args):
        _vna_python.IntVector_swiginit(self, _vna_python.new_IntVector(*args))

    def push_back(self, x):
        return _vna_python.IntVector_push_back(self, x)

    def front(self):
        return _vna_python.IntVector_front(self)

    def back(self):
        return _vna_python.IntVector_back(self)

    def assign(self, n, x):
        return _vna_python.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _vna_python.IntVector_resize(self, *args)

    def insert(self, *args):
        return _vna_python.IntVector_insert(self, *args)

    def reserve(self, n):
        return _vna_python.IntVector_reserve(self, n)

    def capacity(self):
        return _vna_python.IntVector_capacity(self)
    __swig_destroy__ = _vna_python.delete_IntVector

# Register IntVector in _vna_python:
_vna_python.IntVector_swigregister(IntVector)
class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _vna_python.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _vna_python.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _vna_python.DoubleVector___bool__(self)

    def __len__(self):
        return _vna_python.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _vna_python.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _vna_python.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _vna_python.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _vna_python.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _vna_python.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _vna_python.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _vna_python.DoubleVector_pop(self)

    def append(self, x):
        return _vna_python.DoubleVector_append(self, x)

    def empty(self):
        return _vna_python.DoubleVector_empty(self)

    def size(self):
        return _vna_python.DoubleVector_size(self)

    def swap(self, v):
        return _vna_python.DoubleVector_swap(self, v)

    def begin(self):
        return _vna_python.DoubleVector_begin(self)

    def end(self):
        return _vna_python.DoubleVector_end(self)

    def rbegin(self):
        return _vna_python.DoubleVector_rbegin(self)

    def rend(self):
        return _vna_python.DoubleVector_rend(self)

    def clear(self):
        return _vna_python.DoubleVector_clear(self)

    def get_allocator(self):
        return _vna_python.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _vna_python.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _vna_python.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _vna_python.DoubleVector_swiginit(self, _vna_python.new_DoubleVector(*args))

    def push_back(self, x):
        return _vna_python.DoubleVector_push_back(self, x)

    def front(self):
        return _vna_python.DoubleVector_front(self)

    def back(self):
        return _vna_python.DoubleVector_back(self)

    def assign(self, n, x):
        return _vna_python.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _vna_python.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _vna_python.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _vna_python.DoubleVector_reserve(self, n)

    def capacity(self):
        return _vna_python.DoubleVector_capacity(self)
    __swig_destroy__ = _vna_python.delete_DoubleVector

# Register DoubleVector in _vna_python:
_vna_python.DoubleVector_swigregister(DoubleVector)
class MeasPointVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _vna_python.MeasPointVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _vna_python.MeasPointVector___nonzero__(self)

    def __bool__(self):
        return _vna_python.MeasPointVector___bool__(self)

    def __len__(self):
        return _vna_python.MeasPointVector___len__(self)

    def __getslice__(self, i, j):
        return _vna_python.MeasPointVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _vna_python.MeasPointVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _vna_python.MeasPointVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _vna_python.MeasPointVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _vna_python.MeasPointVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _vna_python.MeasPointVector___setitem__(self, *args)

    def pop(self):
        return _vna_python.MeasPointVector_pop(self)

    def append(self, x):
        return _vna_python.MeasPointVector_append(self, x)

    def empty(self):
        return _vna_python.MeasPointVector_empty(self)

    def size(self):
        return _vna_python.MeasPointVector_size(self)

    def swap(self, v):
        return _vna_python.MeasPointVector_swap(self, v)

    def begin(self):
        return _vna_python.MeasPointVector_begin(self)

    def end(self):
        return _vna_python.MeasPointVector_end(self)

    def rbegin(self):
        return _vna_python.MeasPointVector_rbegin(self)

    def rend(self):
        return _vna_python.MeasPointVector_rend(self)

    def clear(self):
        return _vna_python.MeasPointVector_clear(self)

    def get_allocator(self):
        return _vna_python.MeasPointVector_get_allocator(self)

    def pop_back(self):
        return _vna_python.MeasPointVector_pop_back(self)

    def erase(self, *args):
        return _vna_python.MeasPointVector_erase(self, *args)

    def __init__(self, *args):
        _vna_python.MeasPointVector_swiginit(self, _vna_python.new_MeasPointVector(*args))

    def push_back(self, x):
        return _vna_python.MeasPointVector_push_back(self, x)

    def front(self):
        return _vna_python.MeasPointVector_front(self)

    def back(self):
        return _vna_python.MeasPointVector_back(self)

    def assign(self, n, x):
        return _vna_python.MeasPointVector_assign(self, n, x)

    def resize(self, *args):
        return _vna_python.MeasPointVector_resize(self, *args)

    def insert(self, *args):
        return _vna_python.MeasPointVector_insert(self, *args)

    def reserve(self, n):
        return _vna_python.MeasPointVector_reserve(self, n)

    def capacity(self):
        return _vna_python.MeasPointVector_capacity(self)
    __swig_destroy__ = _vna_python.delete_MeasPointVector

# Register MeasPointVector in _vna_python:
_vna_python.MeasPointVector_swigregister(MeasPointVector)
class SParamVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _vna_python.SParamVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _vna_python.SParamVector___nonzero__(self)

    def __bool__(self):
        return _vna_python.SParamVector___bool__(self)

    def __len__(self):
        return _vna_python.SParamVector___len__(self)

    def __getslice__(self, i, j):
        return _vna_python.SParamVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _vna_python.SParamVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _vna_python.SParamVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _vna_python.SParamVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _vna_python.SParamVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _vna_python.SParamVector___setitem__(self, *args)

    def pop(self):
        return _vna_python.SParamVector_pop(self)

    def append(self, x):
        return _vna_python.SParamVector_append(self, x)

    def empty(self):
        return _vna_python.SParamVector_empty(self)

    def size(self):
        return _vna_python.SParamVector_size(self)

    def swap(self, v):
        return _vna_python.SParamVector_swap(self, v)

    def begin(self):
        return _vna_python.SParamVector_begin(self)

    def end(self):
        return _vna_python.SParamVector_end(self)

    def rbegin(self):
        return _vna_python.SParamVector_rbegin(self)

    def rend(self):
        return _vna_python.SParamVector_rend(self)

    def clear(self):
        return _vna_python.SParamVector_clear(self)

    def get_allocator(self):
        return _vna_python.SParamVector_get_allocator(self)

    def pop_back(self):
        return _vna_python.SParamVector_pop_back(self)

    def erase(self, *args):
        return _vna_python.SParamVector_erase(self, *args)

    def __init__(self, *args):
        _vna_python.SParamVector_swiginit(self, _vna_python.new_SParamVector(*args))

    def push_back(self, x):
        return _vna_python.SParamVector_push_back(self, x)

    def front(self):
        return _vna_python.SParamVector_front(self)

    def back(self):
        return _vna_python.SParamVector_back(self)

    def assign(self, n, x):
        return _vna_python.SParamVector_assign(self, n, x)

    def resize(self, *args):
        return _vna_python.SParamVector_resize(self, *args)

    def insert(self, *args):
        return _vna_python.SParamVector_insert(self, *args)

    def reserve(self, n):
        return _vna_python.SParamVector_reserve(self, n)

    def capacity(self):
        return _vna_python.SParamVector_capacity(self)
    __swig_destroy__ = _vna_python.delete_SParamVector

# Register SParamVector in _vna_python:
_vna_python.SParamVector_swigregister(SParamVector)
class TDSampleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _vna_python.TDSampleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _vna_python.TDSampleVector___nonzero__(self)

    def __bool__(self):
        return _vna_python.TDSampleVector___bool__(self)

    def __len__(self):
        return _vna_python.TDSampleVector___len__(self)

    def __getslice__(self, i, j):
        return _vna_python.TDSampleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _vna_python.TDSampleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _vna_python.TDSampleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _vna_python.TDSampleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _vna_python.TDSampleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _vna_python.TDSampleVector___setitem__(self, *args)

    def pop(self):
        return _vna_python.TDSampleVector_pop(self)

    def append(self, x):
        return _vna_python.TDSampleVector_append(self, x)

    def empty(self):
        return _vna_python.TDSampleVector_empty(self)

    def size(self):
        return _vna_python.TDSampleVector_size(self)

    def swap(self, v):
        return _vna_python.TDSampleVector_swap(self, v)

    def begin(self):
        return _vna_python.TDSampleVector_begin(self)

    def end(self):
        return _vna_python.TDSampleVector_end(self)

    def rbegin(self):
        return _vna_python.TDSampleVector_rbegin(self)

    def rend(self):
        return _vna_python.TDSampleVector_rend(self)

    def clear(self):
        return _vna_python.TDSampleVector_clear(self)

    def get_allocator(self):
        return _vna_python.TDSampleVector_get_allocator(self)

    def pop_back(self):
        return _vna_python.TDSampleVector_pop_back(self)

    def erase(self, *args):
        return _vna_python.TDSampleVector_erase(self, *args)

    def __init__(self, *args):
        _vna_python.TDSampleVector_swiginit(self, _vna_python.new_TDSampleVector(*args))

    def push_back(self, x):
        return _vna_python.TDSampleVector_push_back(self, x)

    def front(self):
        return _vna_python.TDSampleVector_front(self)

    def back(self):
        return _vna_python.TDSampleVector_back(self)

    def assign(self, n, x):
        return _vna_python.TDSampleVector_assign(self, n, x)

    def resize(self, *args):
        return _vna_python.TDSampleVector_resize(self, *args)

    def insert(self, *args):
        return _vna_python.TDSampleVector_insert(self, *args)

    def reserve(self, n):
        return _vna_python.TDSampleVector_reserve(self, n)

    def capacity(self):
        return _vna_python.TDSampleVector_capacity(self)
    __swig_destroy__ = _vna_python.delete_TDSampleVector

# Register TDSampleVector in _vna_python:
_vna_python.TDSampleVector_swigregister(TDSampleVector)

