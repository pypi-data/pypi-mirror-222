
class XrayPulses(PulsePattern):
    """An interface to X-ray free electron laser pulses.

    The pulse structure of each train at European XFEL is described by
    the bunch pattern table and accesssible in recorded data through the
    timeserver device.

    This component aids in locating and reading the bunch pattern table,
    as well as providing utility methods to apply the pulse patterns to
    other recorded data. It only considers the X-ray laser pulses
    generated by one of the SASE beamlines and is thus a good choice for
    exclusive use of X-rays or pump-probe experiments with congruent
    optical laser pulses.

    For specific access to pulses from one of the optical laser sources,
    please see the almost correspondig `OpticalLaserPulses` component
    with the same interface.

    Pump-probe experiments with non-overlapping X-ray and optical laser
    pulses may use the `PumpProbePulses` component to combine both
    sources into a single pulse pattern.
    """

    """
    def get_pulse_index(self, with_pulse_id=True):
         """Get a multi-level index for pulse-resolved data.

         Args:
            with_pulse_id (bool, optional): Whether to express train
                slices in a by index or train ID (default).
        """

        return self._make_pulse_index(
            self._get_pulse_mask(self._key.ndarray()), with_pulse_id)

    def search_pulse_patterns(self, with_train_id=True):
        """Search identical pulse patterns in this data.

        Args:
            with_train_id (bool, optional): Whether to express train
                slices in a by index or train ID (default).
        """

        if with_train_id:
             tids = self._key.train_id_coordinates()

             one = np.uint64(1)  # Avoid conversion to float64.

             def gen_slice(start, stop):
                 return by_id[tids[start]:tids[stop-1]+one]
        else:
            # For now disabled, to be replaced by argument later.
            def gen_slice(start, stop):
                return np.s_[start:stop+1]
    """


class OpticalLaserPulses(PulsePattern):
    """An interface to optical laser pulses.

    The pump-probe lasers (LAS or PPL) are optical lasers commonly used
    in conjunction with X-ray pulses for pump-probe experiments. There
    are multiple laser sources called seeds distributed across the SASE
    beamlines and instruments with their pulse patterns also contained
    in the bunch pattern table.

    However, an important difference to the FEL pulses is that only the
    number of pulses and their spacing can be inferred from the bunch
    pattern table. Optical laser pulses **always** starts at offset 0
    for technical reasons, even if they temporally overlap with FEL
    pulses by means of optical delay.

    For experiments where all FEL and PPL laser pulses overlap, it is
    recommended to just use the `XrayPulses` component. Additional
    support for non-overlapping FEL- or PPL-only pulses is provided by
    the `PumpProbePulses` component.
    """



class PumpProbePulses(XrayPulses, OpticalLaserPulses):
    """An interface to combined FEL and PPL pulses.

    Four different ways to anchor PPL pulses:

        * Fixed bunch table position
        * Relative to first pulse in units of bunch table
        * Relative to first pulse in units of pulses

    Args:
        data (extra.data.DataCollection): Data to access bunch pattern
            data from.
        source (str, optional): Source name of a timeserver or pulse
            pattern decoder, only needed if the data includes more than
            one such device or none could not be detected automatically.
        instrument (src, optional): Instrument to interpret FEL and PPL
            pulses of, only needed if the data includes sources from
            more than one instrument or it could not be detected
            automatically.
            May also be a tuple of (sase, ppl_seed).
    """

    # TODO: What to do if the chosen anchoring mode does not work?

    def __init__(self, data, source=None, instrument=None,
                 bunch_table_position=None, bunch_table_offset=None,
                 pulse_offset=None):
        if all([x is None for x in (
            bunch_table_position, bunch_table_offset, pulse_offset
        )]):
            raise ValueError('must specify one of bunch_table_position, '
                             'bunch_table_offset, pulse_offset')

        self._bunch_table_position = bunch_table_position
        self._bunch_table_offset = bunch_table_offset
        self._pulse_offset = pulse_offset
        
        if instrument is None:
            sase = None
            ppl_seed = None
        elif isinstance(instrument, tuple) and len(instrument) == 2:
            sase = int(instrument[0])
            ppl_seed = instrument[1]
        elif isinstance(instrument, str):
            sase = next(iter({
                sase for sase, topics in XrayPulses._sase_topics.items()
                if instrument.upper() in topics}.pop()), 0)

            ppl_seed = instrument
        else:
            raise TypeError('instrument must be str, 2-tuple or None')
        
        # Run the OpticalLaserPulses initializer to handle constraints
        # with pulse pattern decoder.
        OpticalLaserPulses.__init__(self, data, source, ppl_seed=ppl_seed)
        
        # Run missing initialization for XrayPulses.
        if sase is None:
            sase = self._identify_sase(data)
            
        self._sase = sase
        
    def __repr__(self):
        if self._bunch_table_position is not None:
            offset_str = f'@{self._bunch_table_position}b'
        elif self._bunch_table_offset is not None:
            offset_str = f'@SA{self._sase}{self._bunch_table_offset:+d}b'
        elif self._pulse_offset is not None:
            offset_str = f'@SA{self._sase}{self._pulse_offset:+d}p'
        
        if self._with_timeserver:
            source_type = 'timeserver'
        else:
            source_type = 'ppdecoder'

        return "<{} for SA{} / {}{} using {}={}>".format(
                type(self).__name__, self._sase, self._ppl_seed.name,
                offset_str, source_type, self._source.source)

    def _make_pulse_index(self, pulse_mask, with_pulse_id=True):
        # Warning, do NOT use this function with pulse masks not created
        # by get_pulse_mask()!
        # pulse_mask should be an ndarray

        # Turn mask into flags via an int view and cut down to the
        # actual pulses.
        flags = pulse_mask.view(np.int8)
        flags.shape = (pulse_mask.shape[0] * pulse_mask.shape[1],)
        flags = flags[flags > 0]

        # Generates FEL pulse mask
        index = super()._make_pulse_index(pulse_mask, with_pulse_id)

        # Add new columns via frame conversion.
        import pandas as pd
        frame = index.to_frame()
        frame['fel'] = (flags & 0b01) > 0
        frame['ppl'] = (flags & 0b10) > 0

        return pd.MultiIndex.from_frame(frame)
    
    def get_pulse_mask(self, labelled=True):
        mask = np.zeros(self._key.shape, dtype=np.bool_)
        flags = mask.view(np.int8)
        
        for i, (_, fel, ppl) in enumerate(self.trains()):
            if self._bunch_table_position is not None:
                offset = self._bunch_table_position
            elif self._bunch_table_offset is not None:
                offset = fel[0] + self._bunch_table_offset
            elif self._pulse_offset is not None:
                offset = fel[0] + (fel[1] - fel[0]) * self._pulse_offset
            
            flags[i, fel] |= 1
            flags[i, ppl + offset] |= 2
        
        if labelled:
            import xarray as xr
            return xr.DataArray(
                mask,
                dims=['trainId', 'pulseId'],
                coords={'trainId': self._key.train_id_coordinates(),
                        'pulseId': np.arange(mask.shape[1])})
        else:
            return mask

    def is_constant_pattern(self):
        # Perform comparison as an int8 view for a full comparison.
        flags = self.get_pulse_mask(labelled=False).view(np.int8)
        return (flags == flags[0]).all()

    def search_pulse_patterns(self):
        # Technically works, but wouldn't distinguish between FEL and
        # PPL pulses.

        flags = self.get_pulse_mask(labelled=False).view(np.int8)

        def mask_conversion(flags):
            return np.flatnonzero(flags & 0b01), np.flatnonzero(flags & 0b10)

        return self._search_pulse_patterns(flags, mask_conversion)

    def trains(self):
        """Iterate over pulse IDs by train.

        Yields:
            (int, ndarray, ndarray) Train ID, FEL and PPL pulse IDs.
        """

        if self._with_timeserver:
            for train_id, table in self._key.trains():                
                yield train_id, \
                    np.flatnonzero(XrayPulses._mask_table(self, table)), \
                    np.flatnonzero(OpticalLaerPulses._mask_table(self, table))
        else:
            fel_node = XrayPulses._get_ppdecoder_node(self)
            ppl_node = OpticalLaserPulses._get_ppdecoder_node(self)

            # TODO: SourceData.trains()
            for (train_id, fel_ids), (_, fel_num), (_, ppl_ids), (_, ppl_num) in zip(
                self._source[f'{fel_node}.pulseIds'].trains(),
                self._source[f'{fel_node}.nPulses'].trains(),
                self._source[f'{ppl_node}.pulseIds'].trains(),
                self._source[f'{ppl_node}.nPulses'].trains()
            ):
                yield train_id, fel_ids[:fel_num], ppl_ids[:ppl_num]
