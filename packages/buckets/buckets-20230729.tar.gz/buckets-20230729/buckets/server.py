import os
import sys
import ssl
import time
import hmac
import uuid
import json
import sanic
import pickle
import hashlib
import sqlite3
import asyncio
import aiohttp
import mimetypes

APP = sanic.Sanic('kvlog')
APP.config.KEEP_ALIVE_TIMEOUT = 300

LEARNED_CACHE = dict()
MAX_VERSION_CACHE = dict()


class SQLite():
    def __init__(self, db):
        d = hashlib.sha256(db.encode()).hexdigest()
        self.path = os.path.join('db', d[0:3], d[3:6], d + '.sqlite3')

        if not os.path.isfile(self.path):
            os.makedirs(os.path.dirname(self.path), exist_ok=True)

            tmp = os.path.join('db', str(uuid.uuid4()))

            db = sqlite3.connect(tmp)
            db.execute('''create table paxos(
                          key          text,
                          version      unsigned int,
                          promised_seq unsigned int,
                          accepted_seq unsigned int,
                          value        blob)''')
            db.execute('create unique index i0 on paxos(key, version)')
            db.commit()

            os.replace(tmp, self.path)

    def commit(self):
        self.db.commit()

    def __call__(self, query, *args):
        return self.db.execute(query, args).fetchall()

    def __enter__(self):
        self.db = sqlite3.connect(self.path)
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        self.db.rollback()
        self.db.close()


@APP.post('/<phase:str>/<db:str>/<key:str>/<version:int>/<proposal_seq:int>')
async def paxos_server(request, phase, db, key, version, proposal_seq):
    if request.transport.get_extra_info('peercert') is None:
        raise sanic.exceptions.Unauthorized('INVALID_CERTIFICATE')

    with SQLite(db) as sql:
        sql('insert or ignore into paxos values(?,?,0,0,null)', key, version)

        _, _, promised_seq, accepted_seq, value = sql(
            'select * from paxos where key=? and version=?', key, version)[0]

        # This is not part of the paxos protocol.
        #
        # This row is final, but some node might not have participated in this
        # paxos round. When it tries to run a new paxos round for this row,
        # other nodes just pretend to participate so that the paxos round can
        # be completed for that node.
        if promised_seq is None and accepted_seq is None:
            if 'promise' == phase:
                return response([999999999999999, value])

            if 'accept' == phase or 'learn' == phase:
                return response('OK')

        # Standard paxos protocol PROMISE phase
        if 'promise' == phase and proposal_seq > promised_seq:
            sql('update paxos set promised_seq=? where key=? and version=?',
                proposal_seq, key, version)
            sql.commit()

            return response([accepted_seq, value])

        # Standard paxos protocol ACCEPT phase
        if 'accept' == phase and proposal_seq == promised_seq:
            LEARNED_CACHE.pop((db, key), None)
            MAX_VERSION_CACHE.pop((db, key), None)

            value = pickle.loads(request.body)

            sql('''update paxos
                   set accepted_seq=?, value=?
                   where key=? and version=?
                ''', proposal_seq, value, key, version)
            sql('delete from paxos where key=? and version < ?', key, version)
            sql.commit()

            return response('OK')

        # Paxos protocol does not include this phase.
        #
        # If a value for the key is accepted by a majority, it is learned.
        # Our paxos client, after a successful accept phase, asks participating
        # nodes to mark the row as final.
        if 'learn' == phase and promised_seq == accepted_seq == proposal_seq:
            sql('''update paxos
                   set promised_seq=null, accepted_seq=null
                   where key=? and version=?
                ''', key, version)
            sql.commit()

            return response('OK')

    raise sanic.exceptions.BadRequest('UNKNOWN')


async def paxos_client(bucket, key, version, value):
    # paxos seq is an integer in the following format - YYYYmmddHHMMSS
    # This would increase monotonically. Even if same seq is generated by
    # more than one instances of paxos rounds, protocol handles it and rejects
    # the later round (as proposal_seq should be GREATER than the promised_seq)
    url = '{{}}/{}/{}/{}/{}'.format(
        bucket, key, version, time.strftime('%Y%m%d%H%M%S'))

    if version < 1:
        return 'INVALID_VERSION'

    res = await rpc(url.format('promise'))
    if CONF.quorum > len(res):
        return 'NO_PROMISE_QUORUM'

    # Find out the accepted value with the highest accepted_seq
    proposal = (0, value)
    for accepted_seq, val in res.values():
        if accepted_seq > proposal[0]:
            proposal = (accepted_seq, val)

    if not proposal[1]:
        return 'CANT_SET_EMPTY_VALUE'

    res = await rpc(url.format('accept'), proposal[1])
    if CONF.quorum > len(res):
        return 'NO_ACCEPT_QUORUM'

    await rpc(url.format('learn'))

    return 'OK' if 0 == proposal[0] else 'CONFLICT'


def get_hmac(token, salt, user):
    salt = '{}:{}'.format(salt, user).encode()
    return hmac.new(token.encode(), salt, hashlib.sha256).hexdigest()


async def authenticate(request, bucket, user):
    token = request.headers.get('x-token', None)

    if token is None:
        raise sanic.exceptions.Unauthorized('UNAUTHORIZED')

    try:
        await GET(request, bucket, user)
    except Exception:
        pass

    version, value = LEARNED_CACHE.get((bucket, user), (0, None))

    if version > 0:
        profile = json.loads(value)

        if profile['hmac'] != get_hmac(token, profile['salt'], user):
            raise sanic.exceptions.Unauthorized('UNAUTHORIZED')

    return version


@APP.put('/<bucket:str>/<key:str>/<version:int>')
async def PUT(request, bucket, key, version):
    await authenticate(request, bucket, bucket)

    status = await paxos_client(bucket, key, version, request.body)

    if 'CONFLICT' == status:
        raise sanic.exceptions.Forbidden(status)

    if 'OK' != status:
        raise sanic.exceptions.BadRequest(status)

    return sanic.response.json(dict(bucket=bucket, key=key, version=version,
                                    length=len(request.body)))


@APP.post('/<bucket:str>/<user:str>')
async def TOKEN(request, bucket, user):
    version = await authenticate(request, bucket, user)

    salt, token = str(uuid.uuid4()), str(uuid.uuid4())

    obj = dict(bucket=bucket, salt=salt, user=user,
               hmac=get_hmac(token, salt, user),
               cluster=['https://{}'.format(n) for n in CONF.nodes])

    status = await paxos_client(bucket, user, version+1, json.dumps(obj))
    if 'OK' != status:
        raise sanic.exceptions.BadRequest(status)

    return sanic.response.json(dict(bucket=obj['bucket'], user=obj['user'],
                                    token=token, version=version+1,
                                    cluster=obj['cluster']))


@APP.post('/max_version/<bucket:str>/<key:str>')
async def max_version(request, bucket, key):
    if request.transport.get_extra_info('peercert') is None:
        raise sanic.exceptions.Unauthorized('INVALID_CERTIFICATE')

    if (bucket, key) not in MAX_VERSION_CACHE:
        with SQLite(bucket) as sql:
            rows = sql('''select max(version) from paxos
                          where key=? and
                                (accepted_seq > 0 or accepted_seq is null)
                       ''', key)

            if rows[0][0] is not None:
                MAX_VERSION_CACHE[(bucket, key)] = rows[0][0]

    return response(MAX_VERSION_CACHE.get((bucket, key), 0))


@APP.get('/<bucket:str>/<key:str>')
async def GET(request, bucket, key):
    res = await rpc('max_version/{}/{}'.format(bucket, key))
    if CONF.quorum > len(res):
        raise sanic.exceptions.BadRequest('NO_MAX_VERSION_QUORUM')

    version = max(res.values())

    if 0 == version:
        raise sanic.exceptions.NotFound('KEY_NOT_FOUND')

    cached_version, cached_value = LEARNED_CACHE.get((bucket, key), (0, None))
    if version > cached_version:
        for i in range(2):
            with SQLite(bucket) as sql:
                rows = sql('select * from paxos where key=? and version=?',
                           key, version)

            if rows and rows[0][2] is None and rows[0][3] is None:
                LEARNED_CACHE[(bucket, key)] = (rows[0][1], rows[0][4])
                break

            await paxos_client(bucket, key, version, None)

    cached_version, cached_value = LEARNED_CACHE.get((bucket, key), (0, None))

    token = request.headers.get('x-token', None)
    if token is not None:
        profile = json.loads(cached_value)

        if profile['hmac'] == get_hmac(token, profile['salt'], key):
            return sanic.response.text('AUTHENTICATED')

        raise sanic.exceptions.Unauthorized('AUTH_FAILED')

    if cached_version >= version:
        return sanic.response.raw(cached_value, headers={
            'x-key': key,
            'x-bucket': bucket,
            'x-version': cached_version,
            'content-type': mimetypes.guess_type(key)[0]})


def response(obj):
    return sanic.response.raw(pickle.dumps(obj))


async def rpc(url, obj=None):
    servers = CONF.nodes

    if not hasattr(rpc, 'session'):
        SSL = ssl.create_default_context(
            cafile='self_signed.pem',
            purpose=ssl.Purpose.SERVER_AUTH)
        SSL.load_cert_chain('self_signed.pem', 'self_signed.pem')
        SSL.verify_mode = ssl.CERT_REQUIRED

        rpc.session = aiohttp.ClientSession(
            connector=aiohttp.TCPConnector(ssl=SSL))

    responses = await asyncio.gather(
        *[asyncio.ensure_future(rpc.session.post(
            'https://{}/{}'.format(srv, url), data=pickle.dumps(obj)))
          for srv in servers],
        return_exceptions=True)

    result = dict()
    for s, r in zip(servers, responses):
        if type(r) is aiohttp.client_reqrep.ClientResponse:
            if 200 == r.status:
                result[s] = pickle.loads(await r.read())

    return result


class CONF:
    nodes = None
    quorum = None


if '__main__' == __name__:
    HOST, PORT = sys.argv[1].split(':')
    CONF.nodes = set(sys.argv[1:])
    CONF.quorum = int((len(CONF.nodes)/2)+1)

    SSL = ssl.create_default_context(
        cafile='self_signed.pem',
        purpose=ssl.Purpose.CLIENT_AUTH)
    SSL.load_cert_chain('self_signed.pem', 'self_signed.pem')
    SSL.verify_mode = ssl.CERT_OPTIONAL

    APP.run(HOST, int(PORT), single_process=True, access_log=True, ssl=SSL)
