import logging
import re
import cv2 as cv
import numpy as np
import math
from scipy.spatial.distance import cdist

logger = logging.getLogger(__name__)

def find_center_from_contour(contour) -> tuple:
    """ Find the centroid from a contour"""
    M = cv.moments(contour)
    if M['m00'] != 0.0:
        x = int(M['m10']/M['m00'])
        y = int(M['m01']/M['m00'])
    return x,y


def find_strings_with_letters_or_numbers(polylines, text) -> list:
    """
    To find the text containing letters and numbers and return its corresponding object (polylines)
    """
    pattern = re.compile(r'[a-zA-Z0-9]')
    result = []
    for polyline, word_text in zip(polylines, text):
        if re.search(pattern, word_text):
            result.append(polyline)
    return result


def calculate_distance(point1, point2) -> float:
    """ Calculate the distance between two points"""
    return cv.norm(point1, point2, cv.NORM_L2)


def filter_adjacent_points(ellipse_list, distance_threshold) -> list:
    """
    Used to filter out ellipses who are too close to each other and
    only keep the first ellipse detected
    Parameter
    ------
    `ellipse_list`: Accepts a list of ellipses which is generated by cv.fitEllipse
    `distance_threshold`: the minimum distance with other ellipses
    Return
    ------
    A list of ellipses
    """
    filtered_points = []
    points = [ellipse[0] for ellipse in ellipse_list]
    for i, point1 in enumerate(points):
        is_adjacent = False
        for j, point2 in enumerate(points):
            if i != j and calculate_distance(point1, point2) < distance_threshold:
                is_adjacent = True
                break
        if not is_adjacent:
            filtered_points.append(ellipse_list[i])
        elif not any(calculate_distance(point1, fp[0]) < distance_threshold for fp in filtered_points):
            filtered_points.append(ellipse_list[i])
    return filtered_points


def find_box_center_from_xy_tuple(box) -> tuple:
    """ Fina a box (quadrilateral) cemter from four corner points (x,y)"""
    x_sum = 0
    y_sum = 0
    for point in box:
        x_sum += point[0]
        y_sum += point[1]
    center_x = x_sum / 4
    center_y = y_sum / 4
    return (center_x, center_y)


def is_point_inside_ellipse(center, size, angle, point) -> bool:
    """
    To detect whether the given point is inside a ellipse
    Parameter
    ------
    `center`: (x: int, y: int) the centroid of ellipse
    `size`: (int, int) the axes of ellipse
    `angle`: (int) the rotation angle
    `point`: (int, int) the given point
    """
    center = np.round(center).astype("int")
    size = np.round(size).astype("int")
    ellipse = cv.ellipse2Poly(center, size, int(angle), 0, 360, 1)
    result = cv.pointPolygonTest(ellipse, point, False)
    return result >= 0


def ellipse_fitting(image, config) -> list:
    """
    Detect ellipse by fitting contours
    Parameters
    ----------
    `image`: object
        Accepts an image object. Highly recommend to use a binarized image
        object, which has been preprocessed (e.g., removed lines or texts)
    `config`: dict
        A dictionary of params for the function
        - edge_detection_threshold
            - threshold1: 50
            - threshold2: 150
        - contours
            - mode: 0
            - method:2
        - filters - used to filter irrelevant contours
            - contour_length: 10
            - inertia_ratio: 0.5
            - area: 3000
            - min_adjacent_distance: 13
    """
    img_copy = image.copy()
    edge_detection_threshold1 = config.get('edge_detection_threshold', {}).get('threshold1', 50) if config else 50
    edge_detection_threshold2 = config.get('edge_detection_threshold', {}).get('threshold2', 150) if config else 150

    contours_mode = config.get('contours',{}).get('mode', cv.RETR_EXTERNAL) if config else cv.RETR_EXTERNAL
    contours_method = config.get('contours',{}).get('method', cv.CHAIN_APPROX_SIMPLE) if config else cv.CHAIN_APPROX_SIMPLE

    filters_min_contour_length = config['filters'].get('min_contour_length', 10) if config else 10
    filters_min_inertia_ratio = config['filters'].get('min_inertia_ratio', 0.5) if config else 0.5
    filters_min_area = config['filters'].get('min_area', 3000) if config else 3000
    filters_min_adjacent_distance = config['filters'].get('min_adjacent_distance', 13) if config else 13

    binary = cv.Canny(img_copy, edge_detection_threshold1, edge_detection_threshold2)
    cnt, hierarchy = cv.findContours(binary, contours_mode, contours_method)
    ellipse_list_1st_step = []
    for i in range(len(cnt)):
        if len(cnt[i]) >= filters_min_contour_length:
            # ellipse fitting
            ellipse = cv.fitEllipse(cnt[i]) # return center, axes, angle
            large_axis, small_axis = max(ellipse[1]), min(ellipse[1])
            inertia_ratio = small_axis/ large_axis
            # Convert ellipse contour to a valid contour
            center = np.round(ellipse[0]).astype("int")
            contour_points = cv.ellipse2Poly(center, (int(large_axis / 2), int(small_axis / 2)), int(ellipse[2]), 0, 360, 1)
            # Calculate the contour area using cv.contourArea()
            area = cv.contourArea(contour_points)

            if inertia_ratio > filters_min_inertia_ratio and area > filters_min_area:
                ellipse_list_1st_step.append(ellipse)

    # calculate and add distance into criteria
    # using another method as filter to reduce unnecessary calculation of distance between points
    final_ellipse_list = filter_adjacent_points(ellipse_list_1st_step, filters_min_adjacent_distance)
    return final_ellipse_list


def ellipse_ocr_link(ellipse_list, config: dict = None) -> dict:
    """
    Will connect the text from OCR and the ellipse.
    Return a list of ellipse objects which include OCR texts
    Parameter
    ------
    `ellipse_list`: Accepts a list of ellipses which is generated by cv.fitEllipse
    `texts`: Accepts texts object which is generated by text function
    Return
    ------
    ellipse_idx: int
    center: (int, int) representing (x,y)
    size: (int, int) representing length of axes
    angle: int
    texts: list
        text_idx: int
        text: str
        bounding Box: list of arrays
        center: (int, int)
    Sample Code
    ------
    >>> texts = text(image, config, pdf_path) # get OCR text
    >>> ellipse_list = ellipse_fitting(image, config) # get ellipse
    >>> ellipse_data = ellipse_ocr_link(ellipse_list, texts) # link together
    Sample Return
    ------
    >>> example_ellipse_list = [
        {
            "ellipse_idx" : 0,
            "center": (1,0),
            "size"  : (5,6),
            "angle" : 90,
            "texts" : [
                {
                    "text": "first ocr text",
                    "bounding box": np.ndarray,
                    "center": (2,1)
                },
                {
                    "text": "2nd ocr text",
                    "bounding box": np.ndarray,
                    "center": (1,2)
                }
            ]
        },
        {
            "ellipse_idx" : 1,
            "center": (81,90),
            "size"  : (5,6),
            "angle" : 0,
            "texts" : [
                {
                    "text": "first ocr text",
                    "bounding box": np.ndarray,
                    "center": (85,91)
                },
                {
                    "text": "2nd ocr text",
                    "bounding box": np.ndarray,
                    "center": (80,91)
                }
            ]
        }
    ]
    """
    bbox_center_list = [find_box_center_from_xy_tuple(bbox) for bbox in config.get('bbox')]
    final_ellipse = []
    for ellipse_idx, ellipse in enumerate(ellipse_list):
        center = ellipse[0]
        size = ellipse[1]
        angle = ellipse[2]
        ellipse_object = {
            "ellipse_idx"   : str(ellipse_idx),
            "center"        : center,
            "size"          : size,
            "angle"         : angle,
            "texts"         : [],
            "include_text"  : None
        }
        for text_idx, (text, bbox, bbox_center) in enumerate(
            zip(config.get('words', []),
                config.get('bbox', []),
                bbox_center_list)
                ):
            # test bbox_center is inside ellipse
            if is_point_inside_ellipse(center, size, angle, bbox_center):
                ellipse_object['texts'].append(
                    {
                        "text_idx"      : str(text_idx),
                        "text"          : text,
                        "bounding box"  : bbox,
                        "center"        : bbox_center
                    }
                )
        # test and flag if there is any text inside the ellipse
        if not ellipse_object['texts']: 
            ellipse_object['include_text'] = False
        else: 
            ellipse_object['include_text'] = True
        final_ellipse.append(ellipse_object)

    return final_ellipse


def draw_ellipse(markup_image, ellipse_data) -> np.ndarray:
    """ Draw ellipses on image
    Parameters
    ----------
    `markup_image`: object
    `ellipse_list`: Accepts a list of ellipses which is generated by cv.fitEllipse
    Return
    ------
    Return an image object
    """
    img_copy = markup_image.copy()
    for ellipse_idx, ellipse in enumerate(ellipse_data):
        center = np.round(ellipse['center']).astype("int")
        size_for_drawing = tuple(value / 2 for value in ellipse['size'])
        size = np.round(size_for_drawing).astype("int") 
        angle = ellipse['angle']
        if ellipse['include_text']:
            try:
                cv.ellipse(img_copy, center, size, angle, 0, 360, color=(0,0,255), thickness=2)
                cv.circle(img_copy, center, 2, (0,255, 0), -1) # add centroid
            except:
                continue
            cv.putText(img_copy, str(ellipse_idx), org= center, fontScale=1, color=(255, 0, 0), thickness=1, fontFace=cv.FONT_HERSHEY_SIMPLEX)
    return img_copy

def draw_line(markup_image, line_data) -> np.ndarray:
    """ Draw ellipses on image
    Parameters
    ----------
    `markup_image`: object
    `line_data`: Accepts a list of ellipses which is generated by cv.fitEllipse
    Return
    ------
    Return an image object
    """
    img_copy = markup_image.copy()
    if line_data is not None:
        for lidx, line in enumerate(line_data):
            x1, y1, x2, y2 = line['line']
            cv.line(img_copy, (x1, y1), (x2, y2), (255, 0, 0), 2)
            cv.putText(img_copy, str(lidx), org= (x1,y1), fontScale= 0.5, color=(0, 175, 70), thickness=1, fontFace=cv.FONT_HERSHEY_SIMPLEX)
    return img_copy

def scale_contour(contours, scale) -> list:
    """ Scale up/ down the contour boxes"""
    result = []
    for cnt in contours:
        logger.debug("Contour: %s -> %s", type(cnt), cnt)
        cx, cy = find_center_from_contour(cnt)

        cnt_norm = cnt - [cx, cy]
        cnt_scaled = cnt_norm * scale
        cnt_scaled = cnt_scaled + [cx, cy]
        cnt_scaled = cnt_scaled.astype(np.int32)
        result.append(cnt_scaled)

    return result


def remove_text_from_image(image, config) -> np.ndarray:
    """
    Used to remove detected OCR text from image.
    The purpose is to improve accuracy of detecting ellipse by removing noises.
    Parameters
    ----------
    `image`: object
        Accepts an image object. Highly recommend to use a binarized image object.
    `texts`: Accepts texts object which is generated by text function
    `config`: dict
        A dictionary of params for the function
        - text_box_scale_ratio : 0.85
    Returns
    -------
    Return an image object removed texts
    """
    img_copy = image.copy()
    scale_ratio = config.get('text_box_scale_ratio', 0.85) if config else 0.85
    ocr_sep_text = config.get('words', [])
    ocr_contours = config.get('bbox', [])

    ocr_ploylines_with_letterNumber = find_strings_with_letters_or_numbers(ocr_contours, ocr_sep_text)
    scaled_contour = scale_contour(ocr_ploylines_with_letterNumber, scale_ratio)
    img_removed_text_box = cv.drawContours(image=img_copy, contours=scaled_contour , contourIdx=-1, color=(255,255,255), thickness=cv.FILLED)

    return img_removed_text_box

def line_filtering(line_list, config):
    iterate = config.get("iterate", 0) if config else 0
    same_line_max_area = config.get("same_line_max_area", 3000) if config else 3000
    same_line_max_angle_diff = config.get("same_line_max_angle_diff", 7) if config else 7
    same_line_max_spd = config.get("same_line_max_spd", 3) if config else 3
    if iterate < 0: iterate = 0

    for _ in range(iterate + 1):
        combined_indices = set()
        filtered_lines = []
        for i, line1 in enumerate(line_list):
            if i not in combined_indices:
                same_line_indices = [i]
                for j, line2 in enumerate(line_list):
                    if i != j and j not in combined_indices:
                        is_same_line = same_line_test(line1, line2, max_area=same_line_max_area, max_angle_diff=same_line_max_angle_diff, max_spd=same_line_max_spd)
                        if is_same_line:
                            same_line_indices.append(j)
                            combined_indices.add(j)
                
                if len(same_line_indices) > 1:
                    combined_line = line1
                    for index in same_line_indices[1:]:
                        combined_line = combine_line(combined_line, line_list[index])
                    filtered_lines.append(combined_line)
                else:
                    filtered_lines.append(line1)
        line_list = filtered_lines
    return line_list

def line_ocr_link(line_list, config):
    final_lines = []
    for line_idx, line in enumerate(line_list):
        line_object = {
            "line_idx": str(line_idx),
            "line": line,
            "texts":[],
            "include_text":None
        }
        for text_idx, (text, bbox) in enumerate(
            zip(config.get('words', []),
                config.get('bbox', []))
                ):
            # get axis lines
            axis1_line = np.hstack((
                np.mean([bbox[0], bbox[3]], axis=0),
                np.mean([bbox[1], bbox[2]], axis=0)
            )).astype(np.int32)
            axis2_line = np.hstack((
                np.mean([bbox[0], bbox[1]], axis=0),
                np.mean([bbox[2], bbox[3]], axis=0)
            )).astype(np.int32)
            angle_Diff = min(angle_diff(line, axis1_line), angle_diff(line, axis2_line))
            min_dist_to_line = min(perpendicular_distance(point, line) for point in bbox)

            if angle_Diff < 7 and min_dist_to_line < 10:
                line_object['texts'].append(
                    {
                        "text_idx"      : str(text_idx),
                        "text"          : text,
                        "bounding box"  : bbox,
                    }
                )

        # test and flag if there is any text inside the ellipse
        if not line_object['texts']: 
            line_object['include_text'] = False
        else: 
            line_object['include_text'] = True
        final_lines.append(line_object)
    return final_lines


def perpendicular_distance(point, line):
    """
    Calculate the perpendicular distance between a point and a line.

    Parameters
    ----------
        point (tuple): Coordinates of the point as (x, y).
        line (tuple): Endpoints of the line as (x1, y1, x2, y2).

    Returns
    -------
        float: The perpendicular distance between the point and the line.
    """
    x, y = point
    x1, y1, x2, y2 = line

    # Calculate the line direction vector
    line_direction = np.array([x2 - x1, y2 - y1])

    # Calculate the vector from the line's first endpoint to the point
    point_vector = np.array([x - x1, y - y1])

    # Calculate the perpendicular distance
    perpendicular_distance = np.abs(np.cross(line_direction, point_vector)) / np.linalg.norm(line_direction)

    return perpendicular_distance

def get_polar_coordinates(point, centroid):
    x, y = point
    cx, cy = centroid
    radius = math.sqrt((x - cx) ** 2 + (y - cy) ** 2)
    angle = math.atan2(y - cy, x - cx)
    return radius, angle

def get_clockwise_order(box):
    centroid = [sum(p[0] for p in box) / len(box), sum(p[1] for p in box) / len(box)]
    polar_coordinates = [(point, get_polar_coordinates(point, centroid)) for point in box]
    sorted_polar = sorted(polar_coordinates, key=lambda x: x[1][1])
    sorted_points = [p[0] for p in sorted_polar]
    return sorted_points

def line_area(line1, line2):
    """
    Calculate the area enclosed by two lines.

    Args:
        line1 (array): Array containing the endpoints of the first line.
        line2 (array): Array containing the endpoints of the second line.

    Returns:
        float: The area enclosed by the two lines.
    """
    x11, y11, x12, y12 = line1
    x21, y21, x22, y22 = line2

    box = [(x11, y11), (x12, y12), (x21, y21), (x22, y22)]
    box = get_clockwise_order(box)
    # Sort the points in counterclockwise order
    # points = np.array([(x11, y11), (x12, y12), (x21, y21), (x22, y22)])
    # points = order_points(points)
    # Calculate the area formed by the sorted points
    area = 0.5 * abs((box[0][0] * box[1][1] + box[1][0] * box[2][1] + box[2][0] * box[3][1] + box[3][0] * box[0][1])
                    - (box[0][1] * box[1][0] + box[1][1] * box[2][0] + box[2][1] * box[3][0] + box[3][1] * box[0][0]))

    # # Calculate the area formed by four points
    # area = 0.5 * abs(
    #     (x11 * y12 + x12 * y21 + x21 * y22 + x22 * y11) - \
    #         (y11 * x12 + y12 * x21 + y21 * x22 + y22 * x11)
    #         )
    return area

def angle_diff(line1, line2):
    # Extract coordinates of the lines
    x1, y1, x2, y2 = line1
    x3, y3, x4, y4 = line2
    
    # Calculate the direction vectors of the lines
    u = np.array([x2 - x1, y2 - y1])
    v = np.array([x4 - x3, y4 - y3])
    
    # Normalize the direction vectors
    u = u / np.linalg.norm(u)
    v = v / np.linalg.norm(v)
    
    # Calculate the dot product of the normalized direction vectors
    dot_product = np.dot(u, v)
    
    # Calculate the angle difference in radians
    angle_diff_rad = np.arccos(dot_product)
    
    # Convert the angle difference to degrees
    angle_diff_deg = np.degrees(angle_diff_rad)
    
    return angle_diff_deg

def same_line_test(line1, line2, max_area, max_angle_diff, max_spd):
    """
    True: pass the test, two lines are not the same
    False: does not pass, two lines are highly likely the same
    """
    for line in [line1, line2]:
        line[[0, 1, 2, 3]] = line[[2, 3, 0, 1]] if line[0] > line[2] else line
    area = line_area(line1, line2)
    angleDiff = angle_diff(line1, line2)
    # starting_point_distance = utils_graphics.calculate_distance(line1[:2], line2[:2])
    scaled_line = scale_line(line1, 1.5)
    shortest_perp_distance = min(
        perpendicular_distance(line2[:2], scaled_line), 
        perpendicular_distance(line2[2:4], scaled_line))


    if area < max_area and \
        angleDiff < max_angle_diff and \
        shortest_perp_distance < max_spd:
        # starting_point_distance <max_spt and \
        return True
    else: return False

def scale_line(line: np.ndarray, scale_ratio: float= 1) -> np.ndarray:
    """
    Scales a line segment by a given scale ratio, centered at its centroid.

    Parameters
    ------
    - line (np.ndarray): An array representing a line segment with four coordinates:
        [startpt_x, startpt_y, endpt_x, endpt_y].
    - scale_ratio (float): The ratio by which to scale the line segment.
        - A scale_ratio less than 1 reduces the length, while a scale_ratio greater than 1 increases the length.

    Returns
    ------
    np.ndarray: An array representing the scaled line segment with four coordinates:
        [scaled_startpt_x, scaled_startpt_y, scaled_endpt_x, scaled_endpt_y].
    """
    point1 = line[:2]
    point2 = line[2:4]
    centroid = np.mean([point1, point2], axis=0)

    length = np.linalg.norm(point2 - point1)
    scaled_length = length * scale_ratio

    direction = (point1 - point2) / length
    scaled_direction = direction * scaled_length

    startpt = centroid + 0.5 * scaled_direction
    endpt = centroid - 0.5 * scaled_direction

    scaled_line = np.concatenate((startpt, endpt)).astype(np.int32)

    return scaled_line

def perpendicular_distance(point: np.ndarray, line: np.ndarray) -> float:
    """
    Calculates the perpendicular distance from a point to a line segment.

    Args:
        point (np.ndarray): An array representing the coordinates of the point [x, y].
        line (np.ndarray): An array representing a line segment with four coordinates:
                        [startpt_x, startpt_y, endpt_x, endpt_y].

    Returns:
        float: The perpendicular distance from the point to the line segment.
    """
    startpt = line[:2]
    endpt = line[2:4]

    line_direction = endpt - startpt
    line_length = np.linalg.norm(line_direction)

    # If the line has zero length, return the distance between the point and its start point
    if line_length == 0.0:
        return np.linalg.norm(point - startpt)

    # Normalize the line direction vector
    line_direction = line_direction / line_length

    # Calculate the vector from the start point to the given point
    point_vector = point - startpt

    # Calculate the projection of the point vector onto the line direction
    projection = np.dot(point_vector, line_direction)
    
    # Clamp the projection within the range of the line segment
    projection = np.clip(projection, 0.0, line_length)

    # Calculate the perpendicular vector from the point to the line
    perpendicular_vector = point_vector - projection * line_direction

    # Calculate and return the perpendicular distance
    perpendicular_distance = np.linalg.norm(perpendicular_vector)
    return perpendicular_distance

def combine_line(line1, line2):
    points = np.vstack((line1, line2)).reshape(-1,2)
    # Calculate the pairwise distances between points
    distances = cdist(points, points)

    # Find the indices of the maximum distance in the distance matrix
    indices = np.unravel_index(np.argmax(distances), distances.shape)
    point1_index, point2_index = indices

    # Get the two points with the longest distance
    point1 = points[point1_index]
    point2 = points[point2_index]

    new_line = np.hstack((point1, point2))
    return new_line