// ======================================================================
// \title  PassiveParamsComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for PassiveParams component base class
// ======================================================================

#include <cstdio>

#include "Fw/Types/Assert.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "base/PassiveParamsComponentAc.hpp"

namespace {
  // Get the max size by doing a union of the input and internal port serialization sizes
  union BuffUnion {
    BYTE noArgsGuardedPortSize[InputNoArgsPort::SERIALIZED_SIZE];
    BYTE noArgsReturnGuardedPortSize[InputNoArgsReturnPort::SERIALIZED_SIZE];
    BYTE noArgsReturnSyncPortSize[InputNoArgsReturnPort::SERIALIZED_SIZE];
    BYTE noArgsSyncPortSize[InputNoArgsPort::SERIALIZED_SIZE];
    BYTE typedGuardedPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE typedReturnGuardedPortSize[InputTypedReturnPort::SERIALIZED_SIZE];
    BYTE typedReturnSyncPortSize[InputTypedReturnPort::SERIALIZED_SIZE];
    BYTE typedSyncPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE cmdPortSize[Fw::InputCmdPort::SERIALIZED_SIZE];
  };

  // Define a message buffer class large enough to handle all the
  // asynchronous inputs to the component
  class ComponentIpcSerializableBuffer :
    public Fw::SerializeBufferBase
  {

    public:

      enum {
        // Max. message size = size of data + message id + port
        SERIALIZATION_SIZE =
          sizeof(BuffUnion) +
          sizeof(NATIVE_INT_TYPE) +
          sizeof(NATIVE_INT_TYPE)
      };

      NATIVE_UINT_TYPE getBuffCapacity() const {
        return sizeof(m_buff);
      }

      U8* getBuffAddr() {
        return m_buff;
      }

      const U8* getBuffAddr() const {
        return m_buff;
      }

    private:
      // Should be the max of all the input ports serialized sizes...
      U8 m_buff[SERIALIZATION_SIZE];

  };
}

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  init(NATIVE_INT_TYPE instance)
{
  // Initialize base class
  Fw::PassiveComponentBase::init(instance);

  // Connect input port cmdIn
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdIn_InputPorts());
    port++
  ) {
    this->m_cmdIn_InputPort[port].init();
    this->m_cmdIn_InputPort[port].addCallComp(
      this,
      m_p_cmdIn_in
    );
    this->m_cmdIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdIn_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdIn_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsGuarded_InputPort[port].init();
    this->m_noArgsGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsGuarded_in
    );
    this->m_noArgsGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsReturnGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsReturnGuarded_InputPort[port].init();
    this->m_noArgsReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnGuarded_in
    );
    this->m_noArgsReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsReturnGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsReturnGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsReturnSync_InputPorts());
    port++
  ) {
    this->m_noArgsReturnSync_InputPort[port].init();
    this->m_noArgsReturnSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnSync_in
    );
    this->m_noArgsReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsReturnSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsReturnSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsSync_InputPorts());
    port++
  ) {
    this->m_noArgsSync_InputPort[port].init();
    this->m_noArgsSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsSync_in
    );
    this->m_noArgsSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedGuarded_InputPorts());
    port++
  ) {
    this->m_typedGuarded_InputPort[port].init();
    this->m_typedGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedGuarded_in
    );
    this->m_typedGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnGuarded_InputPorts());
    port++
  ) {
    this->m_typedReturnGuarded_InputPort[port].init();
    this->m_typedReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedReturnGuarded_in
    );
    this->m_typedReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnSync_InputPorts());
    port++
  ) {
    this->m_typedReturnSync_InputPort[port].init();
    this->m_typedReturnSync_InputPort[port].addCallComp(
      this,
      m_p_typedReturnSync_in
    );
    this->m_typedReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedSync_InputPorts());
    port++
  ) {
    this->m_typedSync_InputPort[port].init();
    this->m_typedSync_InputPort[port].addCallComp(
      this,
      m_p_typedSync_in
    );
    this->m_typedSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect output port cmdRegOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdRegOut_OutputPorts());
    port++
  ) {
    this->m_cmdRegOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdRegOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdRegOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port cmdResponseOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdResponseOut_OutputPorts());
    port++
  ) {
    this->m_cmdResponseOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdResponseOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdResponseOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port eventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_eventOut_OutputPorts());
    port++
  ) {
    this->m_eventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_eventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_eventOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port prmGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_prmGetOut_OutputPorts());
    port++
  ) {
    this->m_prmGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_prmGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_prmGetOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port prmSetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_prmSetOut_OutputPorts());
    port++
  ) {
    this->m_prmSetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_prmSetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_prmSetOut_OutputPort[port].setObjName(portName);
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect output port textEventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_textEventOut_OutputPorts());
    port++
  ) {
    this->m_textEventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_textEventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_textEventOut_OutputPort[port].setObjName(portName);
#endif
  }
#endif

  // Connect output port timeGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_timeGetOut_OutputPorts());
    port++
  ) {
    this->m_timeGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_timeGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_timeGetOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port tlmOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_tlmOut_OutputPorts());
    port++
  ) {
    this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_tlmOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_tlmOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port typedOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedOut_OutputPorts());
    port++
  ) {
    this->m_typedOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port typedReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnOut_OutputPorts());
    port++
  ) {
    this->m_typedReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnOut_OutputPort[port].setObjName(portName);
#endif
  }
}

// ----------------------------------------------------------------------
// Getters for special input ports
// ----------------------------------------------------------------------

Fw::InputCmdPort* PassiveParamsComponentBase ::
  get_cmdIn_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdIn_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_cmdIn_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for typed input ports
// ----------------------------------------------------------------------

InputNoArgsPort* PassiveParamsComponentBase ::
  get_noArgsGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsGuarded_InputPort[portNum];
}

InputNoArgsReturnPort* PassiveParamsComponentBase ::
  get_noArgsReturnGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnGuarded_InputPort[portNum];
}

InputNoArgsReturnPort* PassiveParamsComponentBase ::
  get_noArgsReturnSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnSync_InputPort[portNum];
}

InputNoArgsPort* PassiveParamsComponentBase ::
  get_noArgsSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsSync_InputPort[portNum];
}

InputTypedPort* PassiveParamsComponentBase ::
  get_typedGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedGuarded_InputPort[portNum];
}

InputTypedReturnPort* PassiveParamsComponentBase ::
  get_typedReturnGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnGuarded_InputPort[portNum];
}

InputTypedReturnPort* PassiveParamsComponentBase ::
  get_typedReturnSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnSync_InputPort[portNum];
}

InputTypedPort* PassiveParamsComponentBase ::
  get_typedSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedSync_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Connect special input ports to special output ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  set_cmdRegOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdRegPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
}

void PassiveParamsComponentBase ::
  set_cmdResponseOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdResponsePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
}

void PassiveParamsComponentBase ::
  set_eventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputLogPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].addCallPort(port);
}

void PassiveParamsComponentBase ::
  set_prmGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputPrmGetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmGetOut_OutputPort[portNum].addCallPort(port);
}

void PassiveParamsComponentBase ::
  set_prmSetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputPrmSetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].addCallPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void PassiveParamsComponentBase ::
  set_textEventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputLogTextPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].addCallPort(port);
}

#endif

void PassiveParamsComponentBase ::
  set_timeGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputTimePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].addCallPort(port);
}

void PassiveParamsComponentBase ::
  set_tlmOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputTlmPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].addCallPort(port);
}

// ----------------------------------------------------------------------
// Connect typed input ports to typed output ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  set_typedOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].addCallPort(port);
}

void PassiveParamsComponentBase ::
  set_typedReturnOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedReturnOut_OutputPort[portNum].addCallPort(port);
}

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to special output ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  set_cmdRegOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveParamsComponentBase ::
  set_cmdResponseOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveParamsComponentBase ::
  set_eventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveParamsComponentBase ::
  set_prmSetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].registerSerialPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void PassiveParamsComponentBase ::
  set_textEventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

void PassiveParamsComponentBase ::
  set_timeGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].registerSerialPort(port);
}

void PassiveParamsComponentBase ::
  set_tlmOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to typed output ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  set_typedOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

// ----------------------------------------------------------------------
// Command registration
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  regCommands()
{
  FW_ASSERT(this->m_cmdRegOut_OutputPort[0].isConnected());

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMU32_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMU32_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMF64_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMF64_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRING_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRING_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMENUM_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMENUM_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMARRAY_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMARRAY_SAVE
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRUCT_SET
  );

  this->m_cmdRegOut_OutputPort[0].invoke(
    this->getIdBase() + OPCODE_PARAMSTRUCT_SAVE
  );
}

// ----------------------------------------------------------------------
// Parameter loading
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  loadParameters()
{
  Fw::ParamBuffer buff;
  Fw::SerializeStatus stat = Fw::FW_SERIALIZE_OK;
  FW_ASSERT(this->m_prmGetOut_OutputPort[0].isConnected());

  FwPrmIdType _id;

  _id = this->getIdBase() + PARAMID_PARAMU32;

  // Get parameter ParamU32
  this->m_param_ParamU32_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamU32_valid == Fw::ParamValid::VALID) {
    stat = buff.deserialize(this->m_ParamU32);
    if (stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamU32_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  _id = this->getIdBase() + PARAMID_PARAMF64;

  // Get parameter ParamF64
  this->m_param_ParamF64_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamF64_valid == Fw::ParamValid::VALID) {
    stat = buff.deserialize(this->m_ParamF64);
    if (stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamF64_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  _id = this->getIdBase() + PARAMID_PARAMSTRING;

  // Get parameter ParamString
  this->m_param_ParamString_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamString_valid == Fw::ParamValid::VALID) {
    stat = buff.deserialize(this->m_ParamString);
    if (stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamString_valid = Fw::ParamValid::DEFAULT;
      // Set default value
      this->m_ParamString = "default";
    }
  }
  else {
    // Set default value
    this->m_param_ParamString_valid = Fw::ParamValid::DEFAULT;
    this->m_ParamString = "default";
  }

  this->m_paramLock.unLock();

  _id = this->getIdBase() + PARAMID_PARAMENUM;

  // Get parameter ParamEnum
  this->m_param_ParamEnum_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamEnum_valid == Fw::ParamValid::VALID) {
    stat = buff.deserialize(this->m_ParamEnum);
    if (stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamEnum_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  _id = this->getIdBase() + PARAMID_PARAMARRAY;

  // Get parameter ParamArray
  this->m_param_ParamArray_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamArray_valid == Fw::ParamValid::VALID) {
    stat = buff.deserialize(this->m_ParamArray);
    if (stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamArray_valid = Fw::ParamValid::DEFAULT;
      // Set default value
      this->m_ParamArray = A(1, 2, 3);
    }
  }
  else {
    // Set default value
    this->m_param_ParamArray_valid = Fw::ParamValid::DEFAULT;
    this->m_ParamArray = A(1, 2, 3);
  }

  this->m_paramLock.unLock();

  _id = this->getIdBase() + PARAMID_PARAMSTRUCT;

  // Get parameter ParamStruct
  this->m_param_ParamStruct_valid =
    this->m_prmGetOut_OutputPort[0].invoke(
      _id,
      buff
    );

  // Deserialize value
  this->m_paramLock.lock();

  // If there was a deserialization issue, mark it invalid
  if (this->m_param_ParamStruct_valid == Fw::ParamValid::VALID) {
    stat = buff.deserialize(this->m_ParamStruct);
    if (stat != Fw::FW_SERIALIZE_OK) {
      this->m_param_ParamStruct_valid = Fw::ParamValid::INVALID;
    }
  }
  else {
    // No default
  }

  this->m_paramLock.unLock();

  // Call notifier
  this->parametersLoaded();
}

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

PassiveParamsComponentBase ::
  PassiveParamsComponentBase(const char* compName) :
    Fw::PassiveComponentBase(compName)
{
  this->m_param_ParamU32_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamF64_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamString_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamEnum_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamArray_valid = Fw::ParamValid::UNINIT;
  this->m_param_ParamStruct_valid = Fw::ParamValid::UNINIT;
}

PassiveParamsComponentBase ::
  ~PassiveParamsComponentBase()
{

}

// ----------------------------------------------------------------------
// Getters for numbers of special input ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_cmdIn_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdIn_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed input ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_noArgsGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsGuarded_InputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_noArgsReturnGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnGuarded_InputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_noArgsReturnSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnSync_InputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_noArgsSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsSync_InputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_typedGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedGuarded_InputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_typedReturnGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnGuarded_InputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_typedReturnSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnSync_InputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_typedSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedSync_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of special output ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_cmdRegOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdRegOut_OutputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_cmdResponseOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdResponseOut_OutputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_eventOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_eventOut_OutputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_prmGetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_prmGetOut_OutputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_prmSetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_prmSetOut_OutputPort));
}

#if FW_ENABLE_TEXT_LOGGING == 1

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_textEventOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_textEventOut_OutputPort));
}

#endif

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_timeGetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_timeGetOut_OutputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_tlmOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_tlmOut_OutputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed output ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_typedOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedOut_OutputPort));
}

NATIVE_INT_TYPE PassiveParamsComponentBase ::
  getNum_typedReturnOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnOut_OutputPort));
}

// ----------------------------------------------------------------------
// Connection status queries for special output ports
// ----------------------------------------------------------------------

bool PassiveParamsComponentBase ::
  isConnected_cmdRegOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdRegOut_OutputPort[portNum].isConnected();
}

bool PassiveParamsComponentBase ::
  isConnected_cmdResponseOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
}

bool PassiveParamsComponentBase ::
  isConnected_eventOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_eventOut_OutputPort[portNum].isConnected();
}

bool PassiveParamsComponentBase ::
  isConnected_prmGetOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_prmGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmGetOut_OutputPort[portNum].isConnected();
}

bool PassiveParamsComponentBase ::
  isConnected_prmSetOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmSetOut_OutputPort[portNum].isConnected();
}

#if FW_ENABLE_TEXT_LOGGING == 1

bool PassiveParamsComponentBase ::
  isConnected_textEventOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_textEventOut_OutputPort[portNum].isConnected();
}

#endif

bool PassiveParamsComponentBase ::
  isConnected_timeGetOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_timeGetOut_OutputPort[portNum].isConnected();
}

bool PassiveParamsComponentBase ::
  isConnected_tlmOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_tlmOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Connection status queries for typed output ports
// ----------------------------------------------------------------------

bool PassiveParamsComponentBase ::
  isConnected_typedOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedOut_OutputPort[portNum].isConnected();
}

bool PassiveParamsComponentBase ::
  isConnected_typedReturnOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedReturnOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Port handler base-class functions for typed input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  noArgsGuarded_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  this->noArgsGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();
}

U32 PassiveParamsComponentBase ::
  noArgsReturnGuarded_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->noArgsReturnGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

U32 PassiveParamsComponentBase ::
  noArgsReturnSync_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->noArgsReturnSync_handler(portNum);

  return retVal;
}

void PassiveParamsComponentBase ::
  noArgsSync_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Down call to pure virtual handler method implemented in Impl class
  this->noArgsSync_handler(portNum);
}

void PassiveParamsComponentBase ::
  typedGuarded_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  this->typedGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();
}

F32 PassiveParamsComponentBase ::
  typedReturnGuarded_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->typedReturnGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

F32 PassiveParamsComponentBase ::
  typedReturnSync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->typedReturnSync_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  return retVal;
}

void PassiveParamsComponentBase ::
  typedSync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Down call to pure virtual handler method implemented in Impl class
  this->typedSync_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Invocation functions for typed output ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  typedOut_out(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_typedOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 PassiveParamsComponentBase ::
  typedReturnOut_out(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_typedReturnOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Command response
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  cmdResponse_out(
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdResponse response
  )
{
  FW_ASSERT(this->m_cmdResponseOut_OutputPort[0].isConnected());
  this->m_cmdResponseOut_OutputPort[0].invoke(opCode, cmdSeq, response);
}

// ----------------------------------------------------------------------
// Parameter update hook
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  parameterUpdated(FwPrmIdType id)
{
  // Do nothing by default
}

void PassiveParamsComponentBase ::
  parametersLoaded()
{
  // Do nothing by default
}

// ----------------------------------------------------------------------
// Parameter get functions
// ----------------------------------------------------------------------

U32 PassiveParamsComponentBase ::
  paramGet_ParamU32(Fw::ParamValid& valid)
{
  U32 _local;
  this->m_paramLock.lock();
  valid = this->m_param_ParamU32_valid;
  _local = this->m_ParamU32;
  this->m_paramLock.unLock();
  return _local;
}

F64 PassiveParamsComponentBase ::
  paramGet_ParamF64(Fw::ParamValid& valid)
{
  F64 _local;
  this->m_paramLock.lock();
  valid = this->m_param_ParamF64_valid;
  _local = this->m_ParamF64;
  this->m_paramLock.unLock();
  return _local;
}

Fw::ParamString PassiveParamsComponentBase ::
  paramGet_ParamString(Fw::ParamValid& valid)
{
  Fw::ParamString _local;
  this->m_paramLock.lock();
  valid = this->m_param_ParamString_valid;
  _local = this->m_ParamString;
  this->m_paramLock.unLock();
  return _local;
}

E PassiveParamsComponentBase ::
  paramGet_ParamEnum(Fw::ParamValid& valid)
{
  E _local;
  this->m_paramLock.lock();
  valid = this->m_param_ParamEnum_valid;
  _local = this->m_ParamEnum;
  this->m_paramLock.unLock();
  return _local;
}

A PassiveParamsComponentBase ::
  paramGet_ParamArray(Fw::ParamValid& valid)
{
  A _local;
  this->m_paramLock.lock();
  valid = this->m_param_ParamArray_valid;
  _local = this->m_ParamArray;
  this->m_paramLock.unLock();
  return _local;
}

S PassiveParamsComponentBase ::
  paramGet_ParamStruct(Fw::ParamValid& valid)
{
  S _local;
  this->m_paramLock.lock();
  valid = this->m_param_ParamStruct_valid;
  _local = this->m_ParamStruct;
  this->m_paramLock.unLock();
  return _local;
}

// ----------------------------------------------------------------------
// Time
// ----------------------------------------------------------------------

Fw::Time PassiveParamsComponentBase ::
  getTime()
{
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    Fw::Time _time;
    this->m_timeGetOut_OutputPort[0].invoke(_time);
    return _time;
  }
  else {
    return Fw::Time(TB_NONE, 0, 0);
  }
}

// ----------------------------------------------------------------------
// Mutex operations for guarded ports
//
// You can override these operations to provide more sophisticated
// synchronization
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  lock()
{
  this->m_guardedPortMutex.lock();
}

void PassiveParamsComponentBase ::
  unLock()
{
  this->m_guardedPortMutex.unLock();
}

// ----------------------------------------------------------------------
// Calls for messages received on special input ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  m_p_cmdIn_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);

  const U32 idBase = callComp->getIdBase();
  FW_ASSERT(opCode >= idBase, opCode, idBase);

  // Select base class function based on opcode
  switch (opCode - idBase) {
    case OPCODE_PARAMU32_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamU32(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMU32_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamU32();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamF64(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMF64_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamF64();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRING_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamString(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRING_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamString();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUM_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamEnum(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMENUM_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamEnum();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAY_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamArray(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMARRAY_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamArray();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCT_SET: {
      Fw::CmdResponse _cstat = compPtr->paramSet_ParamStruct(args);
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }

    case OPCODE_PARAMSTRUCT_SAVE: {
      Fw::CmdResponse _cstat = compPtr->paramSave_ParamStruct();
      compPtr->cmdResponse_out(
        opCode,
        cmdSeq,
        _cstat
      );
      break;
    }
  }
}

// ----------------------------------------------------------------------
// Calls for messages received on typed input ports
// ----------------------------------------------------------------------

void PassiveParamsComponentBase ::
  m_p_noArgsGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  compPtr->noArgsGuarded_handlerBase(portNum);
}

U32 PassiveParamsComponentBase ::
  m_p_noArgsReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  return compPtr->noArgsReturnGuarded_handlerBase(portNum);
}

U32 PassiveParamsComponentBase ::
  m_p_noArgsReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  return compPtr->noArgsReturnSync_handlerBase(portNum);
}

void PassiveParamsComponentBase ::
  m_p_noArgsSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  compPtr->noArgsSync_handlerBase(portNum);
}

void PassiveParamsComponentBase ::
  m_p_typedGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  compPtr->typedGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 PassiveParamsComponentBase ::
  m_p_typedReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  return compPtr->typedReturnGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

F32 PassiveParamsComponentBase ::
  m_p_typedReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  return compPtr->typedReturnSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void PassiveParamsComponentBase ::
  m_p_typedSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  PassiveParamsComponentBase* compPtr = static_cast<PassiveParamsComponentBase*>(callComp);
  compPtr->typedSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Parameter set functions
// ----------------------------------------------------------------------

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSet_ParamU32(Fw::SerializeBufferBase& val)
{
  U32 _local_val;
  Fw::SerializeStatus _stat = val.deserialize(_local_val);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamU32 = _local_val;
  this->m_param_ParamU32_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMU32);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSet_ParamF64(Fw::SerializeBufferBase& val)
{
  F64 _local_val;
  Fw::SerializeStatus _stat = val.deserialize(_local_val);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamF64 = _local_val;
  this->m_param_ParamF64_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMF64);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSet_ParamString(Fw::SerializeBufferBase& val)
{
  Fw::ParamString _local_val;
  Fw::SerializeStatus _stat = val.deserialize(_local_val);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamString = _local_val;
  this->m_param_ParamString_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMSTRING);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSet_ParamEnum(Fw::SerializeBufferBase& val)
{
  E _local_val;
  Fw::SerializeStatus _stat = val.deserialize(_local_val);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamEnum = _local_val;
  this->m_param_ParamEnum_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMENUM);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSet_ParamArray(Fw::SerializeBufferBase& val)
{
  A _local_val;
  Fw::SerializeStatus _stat = val.deserialize(_local_val);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamArray = _local_val;
  this->m_param_ParamArray_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMARRAY);
  return Fw::CmdResponse::OK;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSet_ParamStruct(Fw::SerializeBufferBase& val)
{
  S _local_val;
  Fw::SerializeStatus _stat = val.deserialize(_local_val);
  if (_stat != Fw::FW_SERIALIZE_OK) {
    return Fw::CmdResponse::VALIDATION_ERROR;
  }

  // Assign value only if successfully deserialized
  this->m_paramLock.lock();
  this->m_ParamStruct = _local_val;
  this->m_param_ParamStruct_valid = Fw::ParamValid::VALID;
  this->m_paramLock.unLock();

  // Call notifier
  this->parameterUpdated(PARAMID_PARAMSTRUCT);
  return Fw::CmdResponse::OK;
}

// ----------------------------------------------------------------------
// Parameter save functions
// ----------------------------------------------------------------------

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSave_ParamU32()
{
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    Fw::ParamBuffer saveBuff;
    this->m_paramLock.lock();

    Fw::SerializeStatus stat = saveBuff.serialize(m_ParamU32);

    this->m_paramLock.unLock();
    if (stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    FwPrmIdType id = 0;
    id = this->getIdBase() + PARAMID_PARAMU32;

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      id,
      saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSave_ParamF64()
{
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    Fw::ParamBuffer saveBuff;
    this->m_paramLock.lock();

    Fw::SerializeStatus stat = saveBuff.serialize(m_ParamF64);

    this->m_paramLock.unLock();
    if (stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    FwPrmIdType id = 0;
    id = this->getIdBase() + PARAMID_PARAMF64;

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      id,
      saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSave_ParamString()
{
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    Fw::ParamBuffer saveBuff;
    this->m_paramLock.lock();

    Fw::SerializeStatus stat = saveBuff.serialize(m_ParamString);

    this->m_paramLock.unLock();
    if (stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    FwPrmIdType id = 0;
    id = this->getIdBase() + PARAMID_PARAMSTRING;

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      id,
      saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSave_ParamEnum()
{
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    Fw::ParamBuffer saveBuff;
    this->m_paramLock.lock();

    Fw::SerializeStatus stat = saveBuff.serialize(m_ParamEnum);

    this->m_paramLock.unLock();
    if (stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    FwPrmIdType id = 0;
    id = this->getIdBase() + PARAMID_PARAMENUM;

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      id,
      saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSave_ParamArray()
{
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    Fw::ParamBuffer saveBuff;
    this->m_paramLock.lock();

    Fw::SerializeStatus stat = saveBuff.serialize(m_ParamArray);

    this->m_paramLock.unLock();
    if (stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    FwPrmIdType id = 0;
    id = this->getIdBase() + PARAMID_PARAMARRAY;

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      id,
      saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}

Fw::CmdResponse PassiveParamsComponentBase ::
  paramSave_ParamStruct()
{
  if (this->m_prmSetOut_OutputPort[0].isConnected()) {
    Fw::ParamBuffer saveBuff;
    this->m_paramLock.lock();

    Fw::SerializeStatus stat = saveBuff.serialize(m_ParamStruct);

    this->m_paramLock.unLock();
    if (stat != Fw::FW_SERIALIZE_OK) {
      return Fw::CmdResponse::VALIDATION_ERROR;
    }

    FwPrmIdType id = 0;
    id = this->getIdBase() + PARAMID_PARAMSTRUCT;

    // Save the parameter
    this->m_prmSetOut_OutputPort[0].invoke(
      id,
      saveBuff
    );

    return Fw::CmdResponse::OK;
  }

  return Fw::CmdResponse::EXECUTION_ERROR;
}
