// ======================================================================
// \title  QueuedEventsComponentAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for QueuedEvents component base class
// ======================================================================

#include <cstdio>

#include "Fw/Types/Assert.hpp"
#if FW_ENABLE_TEXT_LOGGING
#include "Fw/Types/String.hpp"
#endif
#include "base/QueuedEventsComponentAc.hpp"

namespace {
  enum MsgTypeEnum {
    QUEUEDEVENTS_COMPONENT_EXIT = Fw::ActiveComponentBase::ACTIVE_COMPONENT_EXIT,
    NOARGSASYNC_NOARGS,
    TYPEDASYNC_TYPED,
    TYPEDASYNCASSERT_TYPED,
    TYPEDASYNCBLOCKPRIORITY_TYPED,
    TYPEDASYNCDROPPRIORITY_TYPED,
  };

  // Get the max size by doing a union of the input and internal port serialization sizes
  union BuffUnion {
    BYTE noArgsAsyncPortSize[InputNoArgsPort::SERIALIZED_SIZE];
    BYTE noArgsGuardedPortSize[InputNoArgsPort::SERIALIZED_SIZE];
    BYTE noArgsReturnGuardedPortSize[InputNoArgsReturnPort::SERIALIZED_SIZE];
    BYTE noArgsReturnSyncPortSize[InputNoArgsReturnPort::SERIALIZED_SIZE];
    BYTE noArgsSyncPortSize[InputNoArgsPort::SERIALIZED_SIZE];
    BYTE typedAsyncPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE typedAsyncAssertPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE typedAsyncBlockPriorityPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE typedAsyncDropPriorityPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE typedGuardedPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE typedReturnGuardedPortSize[InputTypedReturnPort::SERIALIZED_SIZE];
    BYTE typedReturnSyncPortSize[InputTypedReturnPort::SERIALIZED_SIZE];
    BYTE typedSyncPortSize[InputTypedPort::SERIALIZED_SIZE];
    BYTE cmdPortSize[Fw::InputCmdPort::SERIALIZED_SIZE];
  };

  // Define a message buffer class large enough to handle all the
  // asynchronous inputs to the component
  class ComponentIpcSerializableBuffer :
    public Fw::SerializeBufferBase
  {

    public:

      enum {
        // Max. message size = size of data + message id + port
        SERIALIZATION_SIZE =
          sizeof(BuffUnion) +
          sizeof(NATIVE_INT_TYPE) +
          sizeof(NATIVE_INT_TYPE)
      };

      NATIVE_UINT_TYPE getBuffCapacity() const {
        return sizeof(m_buff);
      }

      U8* getBuffAddr() {
        return m_buff;
      }

      const U8* getBuffAddr() const {
        return m_buff;
      }

    private:
      // Should be the max of all the input ports serialized sizes...
      U8 m_buff[SERIALIZATION_SIZE];

  };
}

// ----------------------------------------------------------------------
// Component initialization
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  init(
      NATIVE_INT_TYPE queueDepth,
      NATIVE_INT_TYPE instance
  )
{
  // Initialize base class
  Fw::QueuedComponentBase::init(instance);

  // Connect input port cmdIn
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdIn_InputPorts());
    port++
  ) {
    this->m_cmdIn_InputPort[port].init();
    this->m_cmdIn_InputPort[port].addCallComp(
      this,
      m_p_cmdIn_in
    );
    this->m_cmdIn_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdIn_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdIn_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsAsync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsAsync_InputPorts());
    port++
  ) {
    this->m_noArgsAsync_InputPort[port].init();
    this->m_noArgsAsync_InputPort[port].addCallComp(
      this,
      m_p_noArgsAsync_in
    );
    this->m_noArgsAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsAsync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsAsync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsGuarded_InputPort[port].init();
    this->m_noArgsGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsGuarded_in
    );
    this->m_noArgsGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsReturnGuarded_InputPorts());
    port++
  ) {
    this->m_noArgsReturnGuarded_InputPort[port].init();
    this->m_noArgsReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnGuarded_in
    );
    this->m_noArgsReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsReturnGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsReturnGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsReturnSync_InputPorts());
    port++
  ) {
    this->m_noArgsReturnSync_InputPort[port].init();
    this->m_noArgsReturnSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsReturnSync_in
    );
    this->m_noArgsReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsReturnSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsReturnSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port noArgsSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_noArgsSync_InputPorts());
    port++
  ) {
    this->m_noArgsSync_InputPort[port].init();
    this->m_noArgsSync_InputPort[port].addCallComp(
      this,
      m_p_noArgsSync_in
    );
    this->m_noArgsSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_noArgsSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_noArgsSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedAsync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsync_InputPorts());
    port++
  ) {
    this->m_typedAsync_InputPort[port].init();
    this->m_typedAsync_InputPort[port].addCallComp(
      this,
      m_p_typedAsync_in
    );
    this->m_typedAsync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedAsyncAssert
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsyncAssert_InputPorts());
    port++
  ) {
    this->m_typedAsyncAssert_InputPort[port].init();
    this->m_typedAsyncAssert_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncAssert_in
    );
    this->m_typedAsyncAssert_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsyncAssert_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsyncAssert_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedAsyncBlockPriority
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsyncBlockPriority_InputPorts());
    port++
  ) {
    this->m_typedAsyncBlockPriority_InputPort[port].init();
    this->m_typedAsyncBlockPriority_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncBlockPriority_in
    );
    this->m_typedAsyncBlockPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsyncBlockPriority_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsyncBlockPriority_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedAsyncDropPriority
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedAsyncDropPriority_InputPorts());
    port++
  ) {
    this->m_typedAsyncDropPriority_InputPort[port].init();
    this->m_typedAsyncDropPriority_InputPort[port].addCallComp(
      this,
      m_p_typedAsyncDropPriority_in
    );
    this->m_typedAsyncDropPriority_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedAsyncDropPriority_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedAsyncDropPriority_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedGuarded_InputPorts());
    port++
  ) {
    this->m_typedGuarded_InputPort[port].init();
    this->m_typedGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedGuarded_in
    );
    this->m_typedGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedReturnGuarded
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnGuarded_InputPorts());
    port++
  ) {
    this->m_typedReturnGuarded_InputPort[port].init();
    this->m_typedReturnGuarded_InputPort[port].addCallComp(
      this,
      m_p_typedReturnGuarded_in
    );
    this->m_typedReturnGuarded_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnGuarded_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnGuarded_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedReturnSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnSync_InputPorts());
    port++
  ) {
    this->m_typedReturnSync_InputPort[port].init();
    this->m_typedReturnSync_InputPort[port].addCallComp(
      this,
      m_p_typedReturnSync_in
    );
    this->m_typedReturnSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect input port typedSync
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedSync_InputPorts());
    port++
  ) {
    this->m_typedSync_InputPort[port].init();
    this->m_typedSync_InputPort[port].addCallComp(
      this,
      m_p_typedSync_in
    );
    this->m_typedSync_InputPort[port].setPortNum(port);

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedSync_InputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedSync_InputPort[port].setObjName(portName);
#endif
  }

  // Connect output port cmdRegOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdRegOut_OutputPorts());
    port++
  ) {
    this->m_cmdRegOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdRegOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdRegOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port cmdResponseOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_cmdResponseOut_OutputPorts());
    port++
  ) {
    this->m_cmdResponseOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_cmdResponseOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_cmdResponseOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port eventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_eventOut_OutputPorts());
    port++
  ) {
    this->m_eventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_eventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_eventOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port prmGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_prmGetOut_OutputPorts());
    port++
  ) {
    this->m_prmGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_prmGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_prmGetOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port prmSetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_prmSetOut_OutputPorts());
    port++
  ) {
    this->m_prmSetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_prmSetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_prmSetOut_OutputPort[port].setObjName(portName);
#endif
  }

#if FW_ENABLE_TEXT_LOGGING == 1
  // Connect output port textEventOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_textEventOut_OutputPorts());
    port++
  ) {
    this->m_textEventOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_textEventOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_textEventOut_OutputPort[port].setObjName(portName);
#endif
  }
#endif

  // Connect output port timeGetOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_timeGetOut_OutputPorts());
    port++
  ) {
    this->m_timeGetOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_timeGetOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_timeGetOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port tlmOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_tlmOut_OutputPorts());
    port++
  ) {
    this->m_tlmOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_tlmOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_tlmOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port typedOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedOut_OutputPorts());
    port++
  ) {
    this->m_typedOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedOut_OutputPort[port].setObjName(portName);
#endif
  }

  // Connect output port typedReturnOut
  for (
    PlatformIntType port = 0;
    port < static_cast<PlatformIntType>(this->getNum_typedReturnOut_OutputPorts());
    port++
  ) {
    this->m_typedReturnOut_OutputPort[port].init();

#if FW_OBJECT_NAMES == 1
    char portName[120];
    (void) snprintf(
      portName,
      sizeof(portName),
      "%s_typedReturnOut_OutputPort[%" PRI_PlatformIntType "]",
      this->m_objName,
      port
    );
    this->m_typedReturnOut_OutputPort[port].setObjName(portName);
#endif
  }

  Os::Queue::QueueStatus qStat = this->createQueue(
    queueDepth,
    ComponentIpcSerializableBuffer::SERIALIZATION_SIZE
  );
  FW_ASSERT(
    Os::Queue::QUEUE_OK == qStat,
    static_cast<FwAssertArgType>(qStat)
  );
}

// ----------------------------------------------------------------------
// Getters for special input ports
// ----------------------------------------------------------------------

Fw::InputCmdPort* QueuedEventsComponentBase ::
  get_cmdIn_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdIn_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_cmdIn_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Getters for typed input ports
// ----------------------------------------------------------------------

InputNoArgsPort* QueuedEventsComponentBase ::
  get_noArgsAsync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsAsync_InputPort[portNum];
}

InputNoArgsPort* QueuedEventsComponentBase ::
  get_noArgsGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsGuarded_InputPort[portNum];
}

InputNoArgsReturnPort* QueuedEventsComponentBase ::
  get_noArgsReturnGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnGuarded_InputPort[portNum];
}

InputNoArgsReturnPort* QueuedEventsComponentBase ::
  get_noArgsReturnSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsReturnSync_InputPort[portNum];
}

InputNoArgsPort* QueuedEventsComponentBase ::
  get_noArgsSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_noArgsSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_noArgsSync_InputPort[portNum];
}

InputTypedPort* QueuedEventsComponentBase ::
  get_typedAsync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsync_InputPort[portNum];
}

InputTypedPort* QueuedEventsComponentBase ::
  get_typedAsyncAssert_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsyncAssert_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncAssert_InputPort[portNum];
}

InputTypedPort* QueuedEventsComponentBase ::
  get_typedAsyncBlockPriority_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsyncBlockPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncBlockPriority_InputPort[portNum];
}

InputTypedPort* QueuedEventsComponentBase ::
  get_typedAsyncDropPriority_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedAsyncDropPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedAsyncDropPriority_InputPort[portNum];
}

InputTypedPort* QueuedEventsComponentBase ::
  get_typedGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedGuarded_InputPort[portNum];
}

InputTypedReturnPort* QueuedEventsComponentBase ::
  get_typedReturnGuarded_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnGuarded_InputPort[portNum];
}

InputTypedReturnPort* QueuedEventsComponentBase ::
  get_typedReturnSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedReturnSync_InputPort[portNum];
}

InputTypedPort* QueuedEventsComponentBase ::
  get_typedSync_InputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return &this->m_typedSync_InputPort[portNum];
}

// ----------------------------------------------------------------------
// Connect special input ports to special output ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  set_cmdRegOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdRegPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].addCallPort(port);
}

void QueuedEventsComponentBase ::
  set_cmdResponseOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputCmdResponsePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].addCallPort(port);
}

void QueuedEventsComponentBase ::
  set_eventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputLogPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].addCallPort(port);
}

void QueuedEventsComponentBase ::
  set_prmGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputPrmGetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmGetOut_OutputPort[portNum].addCallPort(port);
}

void QueuedEventsComponentBase ::
  set_prmSetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputPrmSetPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].addCallPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void QueuedEventsComponentBase ::
  set_textEventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputLogTextPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].addCallPort(port);
}

#endif

void QueuedEventsComponentBase ::
  set_timeGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputTimePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].addCallPort(port);
}

void QueuedEventsComponentBase ::
  set_tlmOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputTlmPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].addCallPort(port);
}

// ----------------------------------------------------------------------
// Connect typed input ports to typed output ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  set_typedOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      InputTypedPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].addCallPort(port);
}

void QueuedEventsComponentBase ::
  set_typedReturnOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      InputTypedReturnPort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedReturnOut_OutputPort[portNum].addCallPort(port);
}

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to special output ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  set_cmdRegOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdRegOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedEventsComponentBase ::
  set_cmdResponseOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_cmdResponseOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedEventsComponentBase ::
  set_eventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_eventOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedEventsComponentBase ::
  set_prmSetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_prmSetOut_OutputPort[portNum].registerSerialPort(port);
}

#if FW_ENABLE_TEXT_LOGGING == 1

void QueuedEventsComponentBase ::
  set_textEventOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_textEventOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

void QueuedEventsComponentBase ::
  set_timeGetOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_timeGetOut_OutputPort[portNum].registerSerialPort(port);
}

void QueuedEventsComponentBase ::
  set_tlmOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_tlmOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

#if FW_PORT_SERIALIZATION

// ----------------------------------------------------------------------
// Connect serial input ports to typed output ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  set_typedOut_OutputPort(
      NATIVE_INT_TYPE portNum,
      Fw::InputSerializePort* port
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  this->m_typedOut_OutputPort[portNum].registerSerialPort(port);
}

#endif

// ----------------------------------------------------------------------
// Component construction and destruction
// ----------------------------------------------------------------------

QueuedEventsComponentBase ::
  QueuedEventsComponentBase(const char* compName) :
    Fw::QueuedComponentBase(compName)
{
  this->m_EventActivityLowThrottledThrottle = 0;
  this->m_EventFatalThrottledThrottle = 0;
  this->m_EventWarningLowThrottledThrottle = 0;
}

QueuedEventsComponentBase ::
  ~QueuedEventsComponentBase()
{

}

// ----------------------------------------------------------------------
// Getters for numbers of special input ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_cmdIn_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdIn_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed input ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_noArgsAsync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsAsync_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_noArgsGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsGuarded_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_noArgsReturnGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnGuarded_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_noArgsReturnSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsReturnSync_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_noArgsSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_noArgsSync_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedAsync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsync_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedAsyncAssert_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncAssert_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedAsyncBlockPriority_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncBlockPriority_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedAsyncDropPriority_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedAsyncDropPriority_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedGuarded_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedReturnGuarded_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnGuarded_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedReturnSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnSync_InputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedSync_InputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedSync_InputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of special output ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_cmdRegOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdRegOut_OutputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_cmdResponseOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_cmdResponseOut_OutputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_eventOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_eventOut_OutputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_prmGetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_prmGetOut_OutputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_prmSetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_prmSetOut_OutputPort));
}

#if FW_ENABLE_TEXT_LOGGING == 1

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_textEventOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_textEventOut_OutputPort));
}

#endif

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_timeGetOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_timeGetOut_OutputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_tlmOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_tlmOut_OutputPort));
}

// ----------------------------------------------------------------------
// Getters for numbers of typed output ports
// ----------------------------------------------------------------------

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedOut_OutputPort));
}

NATIVE_INT_TYPE QueuedEventsComponentBase ::
  getNum_typedReturnOut_OutputPorts()
{
  return static_cast<NATIVE_INT_TYPE>(FW_NUM_ARRAY_ELEMENTS(this->m_typedReturnOut_OutputPort));
}

// ----------------------------------------------------------------------
// Connection status queries for special output ports
// ----------------------------------------------------------------------

bool QueuedEventsComponentBase ::
  isConnected_cmdRegOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdRegOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdRegOut_OutputPort[portNum].isConnected();
}

bool QueuedEventsComponentBase ::
  isConnected_cmdResponseOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_cmdResponseOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_cmdResponseOut_OutputPort[portNum].isConnected();
}

bool QueuedEventsComponentBase ::
  isConnected_eventOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_eventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_eventOut_OutputPort[portNum].isConnected();
}

bool QueuedEventsComponentBase ::
  isConnected_prmGetOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_prmGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmGetOut_OutputPort[portNum].isConnected();
}

bool QueuedEventsComponentBase ::
  isConnected_prmSetOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_prmSetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_prmSetOut_OutputPort[portNum].isConnected();
}

#if FW_ENABLE_TEXT_LOGGING == 1

bool QueuedEventsComponentBase ::
  isConnected_textEventOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_textEventOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_textEventOut_OutputPort[portNum].isConnected();
}

#endif

bool QueuedEventsComponentBase ::
  isConnected_timeGetOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_timeGetOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_timeGetOut_OutputPort[portNum].isConnected();
}

bool QueuedEventsComponentBase ::
  isConnected_tlmOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_tlmOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_tlmOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Connection status queries for typed output ports
// ----------------------------------------------------------------------

bool QueuedEventsComponentBase ::
  isConnected_typedOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedOut_OutputPort[portNum].isConnected();
}

bool QueuedEventsComponentBase ::
  isConnected_typedReturnOut_OutputPort(NATIVE_INT_TYPE portNum)
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  return this->m_typedReturnOut_OutputPort[portNum].isConnected();
}

// ----------------------------------------------------------------------
// Port handler base-class functions for typed input ports
//
// Call these functions directly to bypass the corresponding ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  noArgsAsync_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  noArgsAsync_preMsgHook(portNum);
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(NOARGSASYNC_NOARGS)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedEventsComponentBase ::
  noArgsGuarded_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  this->noArgsGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();
}

U32 QueuedEventsComponentBase ::
  noArgsReturnGuarded_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->noArgsReturnGuarded_handler(portNum);

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

U32 QueuedEventsComponentBase ::
  noArgsReturnSync_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  U32 retVal;

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->noArgsReturnSync_handler(portNum);

  return retVal;
}

void QueuedEventsComponentBase ::
  noArgsSync_handlerBase(NATIVE_INT_TYPE portNum)
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_noArgsSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Down call to pure virtual handler method implemented in Impl class
  this->noArgsSync_handler(portNum);
}

void QueuedEventsComponentBase ::
  typedAsync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsync_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNC_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = msg.serialize(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedEventsComponentBase ::
  typedAsyncAssert_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsyncAssert_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncAssert_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNCASSERT_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = msg.serialize(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 0, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedEventsComponentBase ::
  typedAsyncBlockPriority_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsyncBlockPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncBlockPriority_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNCBLOCKPRIORITY_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = msg.serialize(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_BLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 10, _block);

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedEventsComponentBase ::
  typedAsyncDropPriority_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedAsyncDropPriority_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Call pre-message hook
  typedAsyncDropPriority_preMsgHook(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
  ComponentIpcSerializableBuffer msg;
  Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

  // Serialize message ID
  _status = msg.serialize(
    static_cast<NATIVE_INT_TYPE>(TYPEDASYNCDROPPRIORITY_TYPED)
  );
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize port number
  _status = msg.serialize(portNum);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument u32
  _status = msg.serialize(u32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument f32
  _status = msg.serialize(f32);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument b
  _status = msg.serialize(b);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument str1
  _status = msg.serialize(str1);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument e
  _status = msg.serialize(e);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument a
  _status = msg.serialize(a);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Serialize argument s
  _status = msg.serialize(s);
  FW_ASSERT(
    _status == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(_status)
  );

  // Send message
  Os::Queue::QueueBlocking _block = Os::Queue::QUEUE_NONBLOCKING;
  Os::Queue::QueueStatus qStatus = this->m_queue.send(msg, 5, _block);

  if (qStatus == Os::Queue::QUEUE_FULL) {
    this->incNumMsgDropped();
    return;
  }

  FW_ASSERT(
    qStatus == Os::Queue::QUEUE_OK,
    static_cast<FwAssertArgType>(qStatus)
  );
}

void QueuedEventsComponentBase ::
  typedGuarded_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  this->typedGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();
}

F32 QueuedEventsComponentBase ::
  typedReturnGuarded_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnGuarded_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Lock guard mutex before calling
  this->lock();

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->typedReturnGuarded_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  // Unlock guard mutex
  this->unLock();

  return retVal;
}

F32 QueuedEventsComponentBase ::
  typedReturnSync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedReturnSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  F32 retVal;

  // Down call to pure virtual handler method implemented in Impl class
  retVal = this->typedReturnSync_handler(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );

  return retVal;
}

void QueuedEventsComponentBase ::
  typedSync_handlerBase(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Make sure port number is valid
  FW_ASSERT(
    portNum < this->getNum_typedSync_InputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );

  // Down call to pure virtual handler method implemented in Impl class
  this->typedSync_handler(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Pre-message hooks for typed async input ports
//
// Each of these functions is invoked just before processing a message
// on the corresponding port. By default, they do nothing. You can
// override them to provide specific pre-message behavior.
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  noArgsAsync_preMsgHook(NATIVE_INT_TYPE portNum)
{
  // Default: no-op
}

void QueuedEventsComponentBase ::
  typedAsync_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedEventsComponentBase ::
  typedAsyncAssert_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedEventsComponentBase ::
  typedAsyncBlockPriority_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

void QueuedEventsComponentBase ::
  typedAsyncDropPriority_preMsgHook(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  // Default: no-op
}

// ----------------------------------------------------------------------
// Invocation functions for typed output ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  typedOut_out(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );
  this->m_typedOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedEventsComponentBase ::
  typedReturnOut_out(
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(
    portNum < this->getNum_typedReturnOut_OutputPorts(),
    static_cast<FwAssertArgType>(portNum)
  );
  return this->m_typedReturnOut_OutputPort[portNum].invoke(
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

// ----------------------------------------------------------------------
// Event logging functions
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  log_ACTIVITY_HI_EventActivityHigh()
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTACTIVITYHIGH;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;

#if FW_AMPCS_COMPATIBLE
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
    // Serialize the number of arguments
    _status = _logBuff.serialize(static_cast<U8>(0));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_HI,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Activity High occurred";
#else
    const char* _formatString =
      "%s: Event Activity High occurred";
#endif

    char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    (void) snprintf(
      _textBuffer,
      FW_LOG_TEXT_BUFFER_SIZE,
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName,
#endif
      "EventActivityHigh "
    );

    // Null terminate
    _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    Fw::TextLogString _logString = _textBuffer;
    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_HI,
      _logString
    );
  }
#endif
}

void QueuedEventsComponentBase ::
  log_ACTIVITY_LO_EventActivityLowThrottled(
      U32 u32,
      F32 f32,
      bool b
  )
{
  // Check throttle value
  if (this->m_EventActivityLowThrottledThrottle >= EVENTID_EVENTACTIVITYLOWTHROTTLED_THROTTLE) {
    return;
  }
  else {
    this->m_EventActivityLowThrottledThrottle++;
  }

  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTACTIVITYLOWTHROTTLED;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serialize(static_cast<U8>(3));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serialize(
      static_cast<U8>(sizeof(U32))
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serialize(u32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serialize(
      static_cast<U8>(sizeof(F32))
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serialize(f32);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serialize(
      static_cast<U8>(sizeof(U8))
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serialize(b);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_LO,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Activity Low occurred with arguments: %" PRIu32 ", %f, %d";
#else
    const char* _formatString =
      "%s: Event Activity Low occurred with arguments: %" PRIu32 ", %f, %d";
#endif

    char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    (void) snprintf(
      _textBuffer,
      FW_LOG_TEXT_BUFFER_SIZE,
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName,
#endif
      "EventActivityLowThrottled ",
      u32,
      f32,
      b
    );

    // Null terminate
    _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    Fw::TextLogString _logString = _textBuffer;
    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::ACTIVITY_LO,
      _logString
    );
  }
#endif
}

void QueuedEventsComponentBase ::
  log_COMMAND_EventCommand(
      const Fw::LogStringArg& str1,
      const Fw::LogStringArg& str2
  )
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTCOMMAND;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serialize(static_cast<U8>(2));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

    _status = str1.serialize(_logBuff, 80);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = str2.serialize(_logBuff, 100);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::COMMAND,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Command occurred with arguments: %s, %s";
#else
    const char* _formatString =
      "%s: Event Command occurred with arguments: %s, %s";
#endif

    char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    (void) snprintf(
      _textBuffer,
      FW_LOG_TEXT_BUFFER_SIZE,
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName,
#endif
      "EventCommand ",
      str1.toChar(),
      str2.toChar()
    );

    // Null terminate
    _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    Fw::TextLogString _logString = _textBuffer;
    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::COMMAND,
      _logString
    );
  }
#endif
}

void QueuedEventsComponentBase ::
  log_DIAGNOSTIC_EventDiagnostic(E e)
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTDIAGNOSTIC;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serialize(static_cast<U8>(1));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serialize(
      static_cast<U8>(E::SERIALIZED_SIZE)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serialize(e);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::DIAGNOSTIC,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Diagnostic occurred with argument: %s";
#else
    const char* _formatString =
      "%s: Event Diagnostic occurred with argument: %s";
#endif

    char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    Fw::String eStr;
    e.toString(eStr);

    (void) snprintf(
      _textBuffer,
      FW_LOG_TEXT_BUFFER_SIZE,
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName,
#endif
      "EventDiagnostic ",
      eStr.toChar()
    );

    // Null terminate
    _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    Fw::TextLogString _logString = _textBuffer;
    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::DIAGNOSTIC,
      _logString
    );
  }
#endif
}

void QueuedEventsComponentBase ::
  log_FATAL_EventFatalThrottled(A a)
{
  // Check throttle value
  if (this->m_EventFatalThrottledThrottle >= EVENTID_EVENTFATALTHROTTLED_THROTTLE) {
    return;
  }
  else {
    this->m_EventFatalThrottledThrottle++;
  }

  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTFATALTHROTTLED;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serialize(static_cast<U8>(1 + 1));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    // For FATAL, add stack size of 4 and a dummy entry. No support for stacks yet.
    _status = _logBuff.serialize(static_cast<U8>(4));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    _status = _logBuff.serialize(static_cast<U32>(0));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serialize(
      static_cast<U8>(A::SERIALIZED_SIZE)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serialize(a);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::FATAL,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Fatal occurred with argument: %s";
#else
    const char* _formatString =
      "%s: Event Fatal occurred with argument: %s";
#endif

    char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    Fw::String aStr;
    a.toString(aStr);

    (void) snprintf(
      _textBuffer,
      FW_LOG_TEXT_BUFFER_SIZE,
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName,
#endif
      "EventFatalThrottled ",
      aStr.toChar()
    );

    // Null terminate
    _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    Fw::TextLogString _logString = _textBuffer;
    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::FATAL,
      _logString
    );
  }
#endif
}

void QueuedEventsComponentBase ::
  log_WARNING_HI_EventWarningHigh(S s)
{
  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTWARNINGHIGH;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;

#if FW_AMPCS_COMPATIBLE
    // Serialize the number of arguments
    _status = _logBuff.serialize(static_cast<U8>(1));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

#if FW_AMPCS_COMPATIBLE
    // Serialize the argument size
    _status = _logBuff.serialize(
      static_cast<U8>(S::SERIALIZED_SIZE)
    );
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif
    _status = _logBuff.serialize(s);
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_HI,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Warning High occurred with argument: %s";
#else
    const char* _formatString =
      "%s: Event Warning High occurred with argument: %s";
#endif

    char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    Fw::String sStr;
    s.toString(sStr);

    (void) snprintf(
      _textBuffer,
      FW_LOG_TEXT_BUFFER_SIZE,
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName,
#endif
      "EventWarningHigh ",
      sStr.toChar()
    );

    // Null terminate
    _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    Fw::TextLogString _logString = _textBuffer;
    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_HI,
      _logString
    );
  }
#endif
}

void QueuedEventsComponentBase ::
  log_WARNING_LO_EventWarningLowThrottled()
{
  // Check throttle value
  if (this->m_EventWarningLowThrottledThrottle >= EVENTID_EVENTWARNINGLOWTHROTTLED_THROTTLE) {
    return;
  }
  else {
    this->m_EventWarningLowThrottledThrottle++;
  }

  // Get the time
  Fw::Time _logTime;
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    this->m_timeGetOut_OutputPort[0].invoke(_logTime);
  }

  FwEventIdType _id = static_cast<FwEventIdType>(0);

  _id = this->getIdBase() + EVENTID_EVENTWARNINGLOWTHROTTLED;

  // Emit the event on the log port
  if (this->m_eventOut_OutputPort[0].isConnected()) {
    Fw::LogBuffer _logBuff;

#if FW_AMPCS_COMPATIBLE
    Fw::SerializeStatus _status = Fw::FW_SERIALIZE_OK;
    // Serialize the number of arguments
    _status = _logBuff.serialize(static_cast<U8>(0));
    FW_ASSERT(
      _status == Fw::FW_SERIALIZE_OK,
      static_cast<FwAssertArgType>(_status)
    );
#endif

    this->m_eventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_LO,
      _logBuff
    );
  }

  // Emit the event on the text log port
#if FW_ENABLE_TEXT_LOGGING
  if (this->m_textEventOut_OutputPort[0].isConnected()) {
#if FW_OBJECT_NAMES == 1
    const char* _formatString =
      "(%s) %s: Event Warning Low occurred";
#else
    const char* _formatString =
      "%s: Event Warning Low occurred";
#endif

    char _textBuffer[FW_LOG_TEXT_BUFFER_SIZE];

    (void) snprintf(
      _textBuffer,
      FW_LOG_TEXT_BUFFER_SIZE,
      _formatString,
#if FW_OBJECT_NAMES == 1
      this->m_objName,
#endif
      "EventWarningLowThrottled "
    );

    // Null terminate
    _textBuffer[FW_LOG_TEXT_BUFFER_SIZE-1] = 0;
    Fw::TextLogString _logString = _textBuffer;
    this->m_textEventOut_OutputPort[0].invoke(
      _id,
      _logTime,
      Fw::LogSeverity::WARNING_LO,
      _logString
    );
  }
#endif
}

// ----------------------------------------------------------------------
// Event throttle reset functions
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  log_ACTIVITY_LO_EventActivityLowThrottled_ThrottleClear()
{
  // Reset throttle counter
  this->m_EventActivityLowThrottledThrottle = 0;
}

void QueuedEventsComponentBase ::
  log_FATAL_EventFatalThrottled_ThrottleClear()
{
  // Reset throttle counter
  this->m_EventFatalThrottledThrottle = 0;
}

void QueuedEventsComponentBase ::
  log_WARNING_LO_EventWarningLowThrottled_ThrottleClear()
{
  // Reset throttle counter
  this->m_EventWarningLowThrottledThrottle = 0;
}

// ----------------------------------------------------------------------
// Time
// ----------------------------------------------------------------------

Fw::Time QueuedEventsComponentBase ::
  getTime()
{
  if (this->m_timeGetOut_OutputPort[0].isConnected()) {
    Fw::Time _time;
    this->m_timeGetOut_OutputPort[0].invoke(_time);
    return _time;
  }
  else {
    return Fw::Time(TB_NONE, 0, 0);
  }
}

// ----------------------------------------------------------------------
// Mutex operations for guarded ports
//
// You can override these operations to provide more sophisticated
// synchronization
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  lock()
{
  this->m_guardedPortMutex.lock();
}

void QueuedEventsComponentBase ::
  unLock()
{
  this->m_guardedPortMutex.unLock();
}

// ----------------------------------------------------------------------
// Message dispatch functions
// ----------------------------------------------------------------------

Fw::QueuedComponentBase::MsgDispatchStatus QueuedEventsComponentBase ::
  doDispatch()
{
  ComponentIpcSerializableBuffer msg;
  NATIVE_INT_TYPE priority = 0;

  Os::Queue::QueueStatus msgStatus = this->m_queue.receive(
    msg,
    priority,
    Os::Queue::QUEUE_NONBLOCKING
  );
  if (Os::Queue::QUEUE_NO_MORE_MSGS == msgStatus) {
    return Fw::QueuedComponentBase::MSG_DISPATCH_EMPTY;
  }
  else {
    FW_ASSERT(
      msgStatus == Os::Queue::QUEUE_OK,
      static_cast<FwAssertArgType>(msgStatus)
    );
  }

  // Reset to beginning of buffer
  msg.resetDeser();

  NATIVE_INT_TYPE desMsg = 0;
  Fw::SerializeStatus deserStatus = msg.deserialize(desMsg);
  FW_ASSERT(
    deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(deserStatus)
  );

  MsgTypeEnum msgType = static_cast<MsgTypeEnum>(desMsg);

  if (msgType == QUEUEDEVENTS_COMPONENT_EXIT) {
    return MSG_DISPATCH_EXIT;
  }

  NATIVE_INT_TYPE portNum = 0;
  deserStatus = msg.deserialize(portNum);
  FW_ASSERT(
    deserStatus == Fw::FW_SERIALIZE_OK,
    static_cast<FwAssertArgType>(deserStatus)
  );

  switch (msgType) {
    // Handle async input port noArgsAsync
    case NOARGSASYNC_NOARGS: {
      // Call handler function
      this->noArgsAsync_handler(portNum);

      break;
    }

    // Handle async input port typedAsync
    case TYPEDASYNC_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str1
      TypedPortStrings::StringSize80 str1;
      deserStatus = msg.deserialize(str1);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      // Call handler function
      this->typedAsync_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncAssert
    case TYPEDASYNCASSERT_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str1
      TypedPortStrings::StringSize80 str1;
      deserStatus = msg.deserialize(str1);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      // Call handler function
      this->typedAsyncAssert_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncBlockPriority
    case TYPEDASYNCBLOCKPRIORITY_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str1
      TypedPortStrings::StringSize80 str1;
      deserStatus = msg.deserialize(str1);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      // Call handler function
      this->typedAsyncBlockPriority_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    // Handle async input port typedAsyncDropPriority
    case TYPEDASYNCDROPPRIORITY_TYPED: {
      // Deserialize argument u32
      U32 u32;
      deserStatus = msg.deserialize(u32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument f32
      F32 f32;
      deserStatus = msg.deserialize(f32);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument b
      bool b;
      deserStatus = msg.deserialize(b);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument str1
      TypedPortStrings::StringSize80 str1;
      deserStatus = msg.deserialize(str1);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument e
      E e;
      deserStatus = msg.deserialize(e);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument a
      A a;
      deserStatus = msg.deserialize(a);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );

      // Deserialize argument s
      S s;
      deserStatus = msg.deserialize(s);
      FW_ASSERT(
        deserStatus == Fw::FW_SERIALIZE_OK,
        static_cast<FwAssertArgType>(deserStatus)
      );
      // Call handler function
      this->typedAsyncDropPriority_handler(
        portNum,
        u32,
        f32,
        b,
        str1,
        e,
        a,
        s
      );

      break;
    }

    default:
      return MSG_DISPATCH_ERROR;
  }

  return MSG_DISPATCH_OK;
}

// ----------------------------------------------------------------------
// Calls for messages received on special input ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  m_p_cmdIn_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      FwOpcodeType opCode,
      U32 cmdSeq,
      Fw::CmdArgBuffer& args
  )
{
  FW_ASSERT(callComp);

  const U32 idBase = callComp->getIdBase();
  FW_ASSERT(opCode >= idBase, opCode, idBase);
}

// ----------------------------------------------------------------------
// Calls for messages received on typed input ports
// ----------------------------------------------------------------------

void QueuedEventsComponentBase ::
  m_p_noArgsAsync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->noArgsAsync_handlerBase(portNum);
}

void QueuedEventsComponentBase ::
  m_p_noArgsGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->noArgsGuarded_handlerBase(portNum);
}

U32 QueuedEventsComponentBase ::
  m_p_noArgsReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  return compPtr->noArgsReturnGuarded_handlerBase(portNum);
}

U32 QueuedEventsComponentBase ::
  m_p_noArgsReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  return compPtr->noArgsReturnSync_handlerBase(portNum);
}

void QueuedEventsComponentBase ::
  m_p_noArgsSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->noArgsSync_handlerBase(portNum);
}

void QueuedEventsComponentBase ::
  m_p_typedAsync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->typedAsync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsComponentBase ::
  m_p_typedAsyncAssert_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->typedAsyncAssert_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsComponentBase ::
  m_p_typedAsyncBlockPriority_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->typedAsyncBlockPriority_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsComponentBase ::
  m_p_typedAsyncDropPriority_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->typedAsyncDropPriority_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

void QueuedEventsComponentBase ::
  m_p_typedGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->typedGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}

F32 QueuedEventsComponentBase ::
  m_p_typedReturnGuarded_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  return compPtr->typedReturnGuarded_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

F32 QueuedEventsComponentBase ::
  m_p_typedReturnSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedReturnPortStrings::StringSize80& str2,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  return compPtr->typedReturnSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str2,
    e,
    a,
    s
  );
}

void QueuedEventsComponentBase ::
  m_p_typedSync_in(
      Fw::PassiveComponentBase* callComp,
      NATIVE_INT_TYPE portNum,
      U32 u32,
      F32 f32,
      bool b,
      const TypedPortStrings::StringSize80& str1,
      const E& e,
      const A& a,
      const S& s
  )
{
  FW_ASSERT(callComp);
  QueuedEventsComponentBase* compPtr = static_cast<QueuedEventsComponentBase*>(callComp);
  compPtr->typedSync_handlerBase(
    portNum,
    u32,
    f32,
    b,
    str1,
    e,
    a,
    s
  );
}
