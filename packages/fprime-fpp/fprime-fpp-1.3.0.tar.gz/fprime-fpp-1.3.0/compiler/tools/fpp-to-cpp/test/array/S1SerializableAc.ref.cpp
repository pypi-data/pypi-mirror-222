// ======================================================================
// \title  S1SerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for S1 struct
// ======================================================================

#include "cstdio"
#include "cstring"

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/StringUtils.hpp"
#include "S1SerializableAc.hpp"

namespace M {

  // ----------------------------------------------------------------------
  // StringSize80 class
  // ----------------------------------------------------------------------

  S1::StringSize80 ::
    StringSize80() :
      StringBase()
  {
    this->m_buf[0] = 0;
  }

  S1::StringSize80 ::
    StringSize80(const char* src) :
      StringBase()
  {
    Fw::StringUtils::string_copy(this->m_buf, src, sizeof(this->m_buf));
  }

  S1::StringSize80 ::
    StringSize80(const Fw::StringBase& src) :
      StringBase()
  {
    Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
  }

  S1::StringSize80 ::
    StringSize80(const StringSize80& src) :
      StringBase()
  {
    Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
  }

  S1::StringSize80 ::
    ~StringSize80()
  {

  }

  S1::StringSize80& S1::StringSize80 ::
    operator=(const StringSize80& other)
  {
    if (this == &other) {
      return *this;
    }

    Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
    return *this;
  }

  S1::StringSize80& S1::StringSize80 ::
    operator=(const Fw::StringBase& other)
  {
    if (this == &other) {
      return *this;
    }

    Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
    return *this;
  }

  S1::StringSize80& S1::StringSize80 ::
    operator=(const char* other)
  {
    Fw::StringUtils::string_copy(this->m_buf, other, sizeof(this->m_buf));
    return *this;
  }

  const char* S1::StringSize80 ::
    toChar() const
  {
    return this->m_buf;
  }

  NATIVE_UINT_TYPE S1::StringSize80 ::
    getCapacity() const
  {
    return sizeof(this->m_buf);
  }

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  S1 ::
    S1() :
      Serializable(),
      mF32(0.0f),
      mF64(0.0),
      mI16(0),
      mI32(0),
      mI64(0),
      mI8(0),
      mU16(0),
      mU32(0),
      mU64(0),
      mU8(0),
      mBool(false),
      mString("")
  {

  }

  S1 ::
    S1(
        F32 mF32,
        F64 mF64,
        I16 mI16,
        I32 mI32,
        I64 mI64,
        I8 mI8,
        U16 mU16,
        U32 mU32,
        U64 mU64,
        U8 mU8,
        bool mBool,
        const StringSize80& mString
    ) :
      Serializable(),
      mF32(mF32),
      mF64(mF64),
      mI16(mI16),
      mI32(mI32),
      mI64(mI64),
      mI8(mI8),
      mU16(mU16),
      mU32(mU32),
      mU64(mU64),
      mU8(mU8),
      mBool(mBool),
      mString(mString)
  {

  }

  S1 ::
    S1(const S1& obj) :
      Serializable(),
      mF32(obj.mF32),
      mF64(obj.mF64),
      mI16(obj.mI16),
      mI32(obj.mI32),
      mI64(obj.mI64),
      mI8(obj.mI8),
      mU16(obj.mU16),
      mU32(obj.mU32),
      mU64(obj.mU64),
      mU8(obj.mU8),
      mBool(obj.mBool),
      mString(obj.mString)
  {

  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  S1& S1 ::
    operator=(const S1& obj)
  {
    if (this == &obj) {
      return *this;
    }

    set(obj.mF32, obj.mF64, obj.mI16, obj.mI32, obj.mI64, obj.mI8, obj.mU16, obj.mU32, obj.mU64, obj.mU8, obj.mBool, obj.mString);
    return *this;
  }

  bool S1 ::
    operator==(const S1& obj) const
  {
    return (
      (this->mF32 == obj.mF32) &&
      (this->mF64 == obj.mF64) &&
      (this->mI16 == obj.mI16) &&
      (this->mI32 == obj.mI32) &&
      (this->mI64 == obj.mI64) &&
      (this->mI8 == obj.mI8) &&
      (this->mU16 == obj.mU16) &&
      (this->mU32 == obj.mU32) &&
      (this->mU64 == obj.mU64) &&
      (this->mU8 == obj.mU8) &&
      (this->mBool == obj.mBool) &&
      (this->mString == obj.mString)
    );
  }

  bool S1 ::
    operator!=(const S1& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const S1& obj) {
    Fw::String s;
    obj.toString(s);
    os << s.toChar();
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus S1 ::
    serialize(Fw::SerializeBufferBase& buffer) const
  {
    Fw::SerializeStatus status;

    status = buffer.serialize(this->mF32);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mF64);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mI16);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mI32);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mI64);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mI8);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mU16);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mU32);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mU64);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mU8);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mBool);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.serialize(this->mString);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

  Fw::SerializeStatus S1 ::
    deserialize(Fw::SerializeBufferBase& buffer)
  {
    Fw::SerializeStatus status;

    status = buffer.deserialize(this->mF32);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mF64);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mI16);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mI32);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mI64);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mI8);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mU16);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mU32);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mU64);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mU8);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mBool);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
    status = buffer.deserialize(this->mString);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }

    return status;
  }

#if FW_SERIALIZABLE_TO_STRING || BUILD_UT

  void S1 ::
    toString(Fw::StringBase& sb) const
  {
    static const char* formatString =
      "( "
      "mF32 = %f, "
      "mF64 = %f, "
      "mI16 = %" PRIi16 ", "
      "mI32 = %" PRIi32 ", "
      "mI64 = %" PRIi64 ", "
      "mI8 = %" PRIi8 ", "
      "mU16 = %" PRIu16 ", "
      "mU32 = %" PRIu32 ", "
      "mU64 = %" PRIu64 ", "
      "mU8 = %" PRIu8 ", "
      "mBool = %d, "
      "mString = %s"
      " )";

    char outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE];
    (void) snprintf(
      outputString,
      FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE,
      formatString,
      this->mF32,
      this->mF64,
      this->mI16,
      this->mI32,
      this->mI64,
      this->mI8,
      this->mU16,
      this->mU32,
      this->mU64,
      this->mU8,
      this->mBool,
      this->mString.toChar()
    );

    outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE-1] = 0; // NULL terminate
    sb = outputString;
  }

#endif

  // ----------------------------------------------------------------------
  // Setter functions
  // ----------------------------------------------------------------------

  void S1 ::
    set(
        F32 mF32,
        F64 mF64,
        I16 mI16,
        I32 mI32,
        I64 mI64,
        I8 mI8,
        U16 mU16,
        U32 mU32,
        U64 mU64,
        U8 mU8,
        bool mBool,
        const StringSize80& mString
    )
  {
    this->mF32 = mF32;
    this->mF64 = mF64;
    this->mI16 = mI16;
    this->mI32 = mI32;
    this->mI64 = mI64;
    this->mI8 = mI8;
    this->mU16 = mU16;
    this->mU32 = mU32;
    this->mU64 = mU64;
    this->mU8 = mU8;
    this->mBool = mBool;
    this->mString = mString;
  }

  void S1 ::
    setmF32(F32 mF32)
  {
    this->mF32 = mF32;
  }

  void S1 ::
    setmF64(F64 mF64)
  {
    this->mF64 = mF64;
  }

  void S1 ::
    setmI16(I16 mI16)
  {
    this->mI16 = mI16;
  }

  void S1 ::
    setmI32(I32 mI32)
  {
    this->mI32 = mI32;
  }

  void S1 ::
    setmI64(I64 mI64)
  {
    this->mI64 = mI64;
  }

  void S1 ::
    setmI8(I8 mI8)
  {
    this->mI8 = mI8;
  }

  void S1 ::
    setmU16(U16 mU16)
  {
    this->mU16 = mU16;
  }

  void S1 ::
    setmU32(U32 mU32)
  {
    this->mU32 = mU32;
  }

  void S1 ::
    setmU64(U64 mU64)
  {
    this->mU64 = mU64;
  }

  void S1 ::
    setmU8(U8 mU8)
  {
    this->mU8 = mU8;
  }

  void S1 ::
    setmBool(bool mBool)
  {
    this->mBool = mBool;
  }

  void S1 ::
    setmString(const StringSize80& mString)
  {
    this->mString = mString;
  }

}
