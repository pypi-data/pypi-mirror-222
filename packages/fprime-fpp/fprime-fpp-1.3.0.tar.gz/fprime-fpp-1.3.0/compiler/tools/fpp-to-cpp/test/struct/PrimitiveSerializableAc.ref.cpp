// ======================================================================
// \title  PrimitiveSerializableAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for Primitive struct
// ======================================================================

#include "cstdio"
#include "cstring"

#include "Fw/Types/Assert.hpp"
#include "Fw/Types/StringUtils.hpp"
#include "PrimitiveSerializableAc.hpp"

// ----------------------------------------------------------------------
// StringSize80 class
// ----------------------------------------------------------------------

Primitive::StringSize80 ::
  StringSize80() :
    StringBase()
{
  this->m_buf[0] = 0;
}

Primitive::StringSize80 ::
  StringSize80(const char* src) :
    StringBase()
{
  Fw::StringUtils::string_copy(this->m_buf, src, sizeof(this->m_buf));
}

Primitive::StringSize80 ::
  StringSize80(const Fw::StringBase& src) :
    StringBase()
{
  Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
}

Primitive::StringSize80 ::
  StringSize80(const StringSize80& src) :
    StringBase()
{
  Fw::StringUtils::string_copy(this->m_buf, src.toChar(), sizeof(this->m_buf));
}

Primitive::StringSize80 ::
  ~StringSize80()
{

}

Primitive::StringSize80& Primitive::StringSize80 ::
  operator=(const StringSize80& other)
{
  if (this == &other) {
    return *this;
  }

  Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
  return *this;
}

Primitive::StringSize80& Primitive::StringSize80 ::
  operator=(const Fw::StringBase& other)
{
  if (this == &other) {
    return *this;
  }

  Fw::StringUtils::string_copy(this->m_buf, other.toChar(), sizeof(this->m_buf));
  return *this;
}

Primitive::StringSize80& Primitive::StringSize80 ::
  operator=(const char* other)
{
  Fw::StringUtils::string_copy(this->m_buf, other, sizeof(this->m_buf));
  return *this;
}

const char* Primitive::StringSize80 ::
  toChar() const
{
  return this->m_buf;
}

NATIVE_UINT_TYPE Primitive::StringSize80 ::
  getCapacity() const
{
  return sizeof(this->m_buf);
}

// ----------------------------------------------------------------------
// Constructors
// ----------------------------------------------------------------------

Primitive ::
  Primitive() :
    Serializable(),
    mF64(0.0),
    mI16(0),
    mI32(0),
    mI64(0),
    mI8(0),
    mU16(0),
    mU32(0),
    mU64(0),
    mU8(0),
    m_bool(false),
    m_string("")
{
  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    this->mF32[i] = 0.0f;
  }
}

Primitive ::
  Primitive(
      const Type_of_mF32& mF32,
      F64 mF64,
      I16 mI16,
      I32 mI32,
      I64 mI64,
      I8 mI8,
      U16 mU16,
      U32 mU32,
      U64 mU64,
      U8 mU8,
      bool m_bool,
      const StringSize80& m_string
  ) :
    Serializable(),
    mF64(mF64),
    mI16(mI16),
    mI32(mI32),
    mI64(mI64),
    mI8(mI8),
    mU16(mU16),
    mU32(mU32),
    mU64(mU64),
    mU8(mU8),
    m_bool(m_bool),
    m_string(m_string)
{
  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    this->mF32[i] = mF32[i];
  }
}

Primitive ::
  Primitive(const Primitive& obj) :
    Serializable(),
    mF64(obj.mF64),
    mI16(obj.mI16),
    mI32(obj.mI32),
    mI64(obj.mI64),
    mI8(obj.mI8),
    mU16(obj.mU16),
    mU32(obj.mU32),
    mU64(obj.mU64),
    mU8(obj.mU8),
    m_bool(obj.m_bool),
    m_string(obj.m_string)
{
  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    this->mF32[i] = obj.mF32[i];
  }
}

Primitive ::
  Primitive(
      F32 mF32,
      F64 mF64,
      I16 mI16,
      I32 mI32,
      I64 mI64,
      I8 mI8,
      U16 mU16,
      U32 mU32,
      U64 mU64,
      U8 mU8,
      bool m_bool,
      const StringSize80& m_string
  ) :
    Serializable(),
    mF64(mF64),
    mI16(mI16),
    mI32(mI32),
    mI64(mI64),
    mI8(mI8),
    mU16(mU16),
    mU32(mU32),
    mU64(mU64),
    mU8(mU8),
    m_bool(m_bool),
    m_string(m_string)
{
  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    this->mF32[i] = mF32;
  }
}

// ----------------------------------------------------------------------
// Operators
// ----------------------------------------------------------------------

Primitive& Primitive ::
  operator=(const Primitive& obj)
{
  if (this == &obj) {
    return *this;
  }

  set(obj.mF32, obj.mF64, obj.mI16, obj.mI32, obj.mI64, obj.mI8, obj.mU16, obj.mU32, obj.mU64, obj.mU8, obj.m_bool, obj.m_string);
  return *this;
}

bool Primitive ::
  operator==(const Primitive& obj) const
{
  // Compare non-array members
  if (!(
    (this->mF64 == obj.mF64) &&
    (this->mI16 == obj.mI16) &&
    (this->mI32 == obj.mI32) &&
    (this->mI64 == obj.mI64) &&
    (this->mI8 == obj.mI8) &&
    (this->mU16 == obj.mU16) &&
    (this->mU32 == obj.mU32) &&
    (this->mU64 == obj.mU64) &&
    (this->mU8 == obj.mU8) &&
    (this->m_bool == obj.m_bool) &&
    (this->m_string == obj.m_string)
  )) {
    return false;
  }

  // Compare array members
  if (!(this->mF32 == obj.mF32)) {
    for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
      if (!(this->mF32[i] == obj.mF32[i])) {
        return false;
      }
    }
  }

  return true;
}

bool Primitive ::
  operator!=(const Primitive& obj) const
{
  return !(*this == obj);
}

#ifdef BUILD_UT

std::ostream& operator<<(std::ostream& os, const Primitive& obj) {
  Fw::String s;
  obj.toString(s);
  os << s.toChar();
  return os;
}

#endif

// ----------------------------------------------------------------------
// Member functions
// ----------------------------------------------------------------------

Fw::SerializeStatus Primitive ::
  serialize(Fw::SerializeBufferBase& buffer) const
{
  Fw::SerializeStatus status;

  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    status = buffer.serialize(this->mF32[i]);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
  }
  status = buffer.serialize(this->mF64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mI16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mI32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mI64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mI8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mU16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mU32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mU64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->mU8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_bool);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.serialize(this->m_string);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }

  return status;
}

Fw::SerializeStatus Primitive ::
  deserialize(Fw::SerializeBufferBase& buffer)
{
  Fw::SerializeStatus status;

  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    status = buffer.deserialize(this->mF32[i]);
    if (status != Fw::FW_SERIALIZE_OK) {
      return status;
    }
  }
  status = buffer.deserialize(this->mF64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mI16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mI32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mI64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mI8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mU16);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mU32);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mU64);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->mU8);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_bool);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }
  status = buffer.deserialize(this->m_string);
  if (status != Fw::FW_SERIALIZE_OK) {
    return status;
  }

  return status;
}

#if FW_SERIALIZABLE_TO_STRING || BUILD_UT

void Primitive ::
  toString(Fw::StringBase& sb) const
{
  static const char* formatString =
    "( "
    "mF32 = [ %f, "
    "%f, "
    "%f ], "
    "mF64 = %f, "
    "mI16 = %" PRIi16 ", "
    "mI32 = %" PRIi32 ", "
    "mI64 = %" PRIi64 ", "
    "mI8 = %" PRIi8 ", "
    "mU16 = %" PRIu16 ", "
    "mU32 = %" PRIu32 ", "
    "mU64 = %" PRIu64 ", "
    "mU8 = %" PRIu8 ", "
    "m_bool = %d, "
    "m_string = %s"
    " )";

  char outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE];
  (void) snprintf(
    outputString,
    FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE,
    formatString,
    this->mF32[0],
    this->mF32[1],
    this->mF32[2],
    this->mF64,
    this->mI16,
    this->mI32,
    this->mI64,
    this->mI8,
    this->mU16,
    this->mU32,
    this->mU64,
    this->mU8,
    this->m_bool,
    this->m_string.toChar()
  );

  outputString[FW_SERIALIZABLE_TO_STRING_BUFFER_SIZE-1] = 0; // NULL terminate
  sb = outputString;
}

#endif

// ----------------------------------------------------------------------
// Setter functions
// ----------------------------------------------------------------------

void Primitive ::
  set(
      const Type_of_mF32& mF32,
      F64 mF64,
      I16 mI16,
      I32 mI32,
      I64 mI64,
      I8 mI8,
      U16 mU16,
      U32 mU32,
      U64 mU64,
      U8 mU8,
      bool m_bool,
      const StringSize80& m_string
  )
{
  this->mF64 = mF64;
  this->mI16 = mI16;
  this->mI32 = mI32;
  this->mI64 = mI64;
  this->mI8 = mI8;
  this->mU16 = mU16;
  this->mU32 = mU32;
  this->mU64 = mU64;
  this->mU8 = mU8;
  this->m_bool = m_bool;
  this->m_string = m_string;

  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    this->mF32[i] = mF32[i];
  }
}

void Primitive ::
  setmF32(const Type_of_mF32& mF32)
{
  for (NATIVE_UINT_TYPE i = 0; i < 3; i++) {
    this->mF32[i] = mF32[i];
  }
}

void Primitive ::
  setmF64(F64 mF64)
{
  this->mF64 = mF64;
}

void Primitive ::
  setmI16(I16 mI16)
{
  this->mI16 = mI16;
}

void Primitive ::
  setmI32(I32 mI32)
{
  this->mI32 = mI32;
}

void Primitive ::
  setmI64(I64 mI64)
{
  this->mI64 = mI64;
}

void Primitive ::
  setmI8(I8 mI8)
{
  this->mI8 = mI8;
}

void Primitive ::
  setmU16(U16 mU16)
{
  this->mU16 = mU16;
}

void Primitive ::
  setmU32(U32 mU32)
{
  this->mU32 = mU32;
}

void Primitive ::
  setmU64(U64 mU64)
{
  this->mU64 = mU64;
}

void Primitive ::
  setmU8(U8 mU8)
{
  this->mU8 = mU8;
}

void Primitive ::
  setm_bool(bool m_bool)
{
  this->m_bool = m_bool;
}

void Primitive ::
  setm_string(const StringSize80& m_string)
{
  this->m_string = m_string;
}
