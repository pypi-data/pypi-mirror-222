pipeline {

  environment {
    PATH_HOME = "/home/jenkins"
    TEST_REPORT_DIR="/root/test-reports"
    PYTHONPYCACHEPREFIX = "/tmp/.pytest_cache"
    PYTHONDONTWRITEBYTECODE = "1"
    GIT_AUTH = credentials('bitbucket-user')

    MAJOR_VERSION = "0"
    MINOR_VERSION = "4"
  }

  agent none

  triggers {
    upstream(upstreamProjects: "pyimporters_plugins/" + env.BRANCH_NAME.replaceAll("/", "%2F"),\
                                threshold: hudson.model.Result.SUCCESS)
  }

  stages {

    stage('Catch build termination') {
      agent {
        node {
          label 'built-in'
          customWorkspace "/home/jenkins/${env.JOB_NAME}"
        }
      }
      stages {
        stage('Skip build if useless') {
          steps {
            script {
              skipBuild()
            }
          }
        }
      }
    }

    stage('Generate new version') {
      when {
        environment name: "DONT_SKIP_JOB", value: "1"
      }

      agent {
        node {
          label 'built-in'
          customWorkspace "/home/jenkins/${env.JOB_NAME}"
        }
      }

      stages {

        stage('Add credentials') {
          steps {
            script {
              // Add password file for flit publishing
              sh "cp ${env.PATH_HOME}/.passwd-pypi .env"
            }
          }
        }

        stage('Commit new version') {
          steps {
            script {
              println("attempt to publish ${env.JOB_NAME} with version: ${MAJOR_VERSION}.${MINOR_VERSION}.${env.BUILD_ID}")

              // push updates of file __init__.py
              withCredentials([gitUsernamePassword(credentialsId: 'bitbucket-user', gitToolName: 'git-tool')]) {
                sh "echo '\"\"\"Sherpa knowledge import plugins\"\"\"' > pyimporters_csv/__init__.py"
                sh "echo '__version__ = \"${MAJOR_VERSION}.${MINOR_VERSION}.${env.BUILD_ID}\"' >> pyimporters_csv/__init__.py"
                sh 'git commit pyimporters_csv/__init__.py -m "[Jenkins CI] Commit on version files" || echo "No changes to commit"'
                sh 'git push'
              }
            }
          }
        }

      }
    }

    stage('Build, test and publish') {
      when {
        environment name: "DONT_SKIP_JOB", value: "1"
      }

      agent {
        // dockerfile agent
        // Mounted volume for Junit reports
        //   - docker: /root/test-reports
        //   - host  : /tmp/_${env.JOB_NAME}/test-reports
        dockerfile {
          label 'built-in'
          customWorkspace "/home/jenkins/${env.JOB_NAME}"
          filename 'Dockerfile'
          args "-u root --privileged -v /tmp/_${env.JOB_NAME}/test-reports:${TEST_REPORT_DIR}"
        }
      }

      stages {

        stage('Install flit & flake8') {
          steps {
            sh 'python -m pip install pip==22.0.3'
            sh 'pip install --no-cache-dir flit==3.2.0 flake8==3.9.2 flakehell'
            sh 'flit install'
          }
        }

        stage('Lint python code') {
          steps {
            sh 'flakehell lint'
          }
        }

        stage('Test with pytest') {
          steps {
            // purge python cache from any previous run
            sh "rm -rf ${PYTHONPYCACHEPREFIX}"
            // remove any previous results.xml file
            sh "rm -f ${TEST_REPORT_DIR}/results.xml"
            sh "pytest --verbose -o cache_dir=${PYTHONPYCACHEPREFIX} --junit-xml ${TEST_REPORT_DIR}/results.xml"
            // purge python cache
            sh "rm -rf ${PYTHONPYCACHEPREFIX}"
          }
        }

        stage('Publish on PyPI') {
          environment {
            FLIT_USERNAME = getUserName ".env"
            FLIT_PASSWORD = getUserPass ".env"
          }
          steps {
            // remove any previous folder dist
            sh 'rm -rf dist'
            // create (as root) folder dist
            sh 'mkdir dist'
            // pull recent updates of file __init__.py
            withCredentials([gitUsernamePassword(credentialsId: 'bitbucket-user', gitToolName: 'git-tool')]) {
              sh 'git config --global pull.rebase false'
              sh "git config --global --add safe.directory ${PATH_HOME}/${env.JOB_NAME}"
              sh 'git pull'
            }
            // put back owner of pulled file
            sh 'chown 1000:1000 pyimporters_csv/__init__.py'
            // get git status
            sh 'git status'
            // publish on PyPI
            sh 'flit publish'
            // remove current folder dist
            sh 'rm -rf dist'
            // remove current folder .hypothesis
            sh 'rm -rf .hypothesis'
            // remove current folder .tox
            sh 'rm -rf .tox'
          }
        }

      }

    }

  }

  post {
    // only triggered when blue or green sign
    success {
      // node is specified here to get an agent
      node('built-in') {
        // keep using customWorkspace to store Junit report
        ws("/home/jenkins/${env.JOB_NAME}") {
          script {
            try {
              sh "rm -f results.xml"
              sh "cp /tmp/_${env.JOB_NAME}/test-reports/results.xml results.xml"
            } catch (Exception e) {
              echo 'Exception occurred: ' + e.toString()
            }
            try {
              junit 'results.xml'
            } catch (Exception e) {
              echo 'Exception occurred: ' + e.toString()
            }
            if (getEmailNotif("/home/jenkins/${env.JOB_NAME}") == '0') {
              println "sending Success Build notification"
              emailext(body: '${DEFAULT_CONTENT}', mimeType: 'text/html',
                    replyTo: '${DEFAULT_REPLYTO}', subject: '${DEFAULT_SUBJECT}',
                    to: '${DEFAULT_RECIPIENTS}')
            } else {
              println "preventing Success Build notification"
            }
          }
        }
      }
    }
    // triggered when red sign
    failure {
      // node is specified here to get an agent
      node('built-in') {
        // keep using customWorkspace to store Junit report
        ws("/home/jenkins/${env.JOB_NAME}") {
          script {
            try {
              sh "rm -f results.xml"
              sh "cp /tmp/_${env.JOB_NAME}/test-reports/results.xml results.xml"
            } catch (Exception e) {
              echo 'Exception occurred: ' + e.toString()
            }
            try {
              junit 'results.xml'
            } catch (Exception e) {
              echo 'Exception occurred: ' + e.toString()
            }
            println "sending Failure Build notification"
            emailext(body: '${DEFAULT_CONTENT}', mimeType: 'text/html',
                    replyTo: '${DEFAULT_REPLYTO}', subject: '${DEFAULT_SUBJECT}',
                    to: '${DEFAULT_RECIPIENTS}')
          }
        }
      }
    }
    // triggered when black sign
    aborted {
      println "post-declarative message: abort job"
    }
    // trigger every-works
    always {
      // node is specified here to get an agent
      node('built-in') {
        // keep using customWorkspace to store Junit report
        ws("/home/jenkins/${env.JOB_NAME}") {
          script {
            switchEmailNotif(false)
          }
        }
      }
    }
  }

}

// return FLIT_USERNAME from given file
def getUserName(path) {
  USERNAME = sh(
                 script: "grep FLIT_USERNAME ${path}|cut -d '=' -f2",
                 returnStdout: true
               ).trim()
  return USERNAME
}

// return FLIT_PASSWORD from given file
def getUserPass(path) {
  USERPASS = sh(
                 script: "grep FLIT_PASSWORD ${path}|cut -d '=' -f2",
                 returnStdout: true
               ).trim()
  return USERPASS
}

// create/remove emailNotif file to trigger email notification
def switchEmailNotif(toggle) {
  if (toggle) {
    sh 'touch .emailNotif'
  } else {
    sh 'rm -f .emailNotif'
  }
}

// return true if emailNotif file present
def getEmailNotif(path) {
  EMAILNOTIF = sh(
                 script: "find ${path} -name '.emailNotif'|wc -l",
                 returnStdout: true
               ).trim()
  return EMAILNOTIF
}

def skipBuild() {
  def upstream_projects = ["pyimporters_plugins"]
  def upstream_running = null
  def jobName
  // iterate over upstream_projects
  for (upstream_project in upstream_projects) {
    Jenkins.instance.getItemByFullName(upstream_project).getItems().each { repository ->
      def isRunning = false
      //repository.parent.name: project
      //repository.name: branch
      if ( repository.name == env.BRANCH_NAME ) {
        // iterate over all jobs of current repository
        repository.getAllJobs().each { job ->
          // iterate over all builds of current job
          job.builds.each { build ->
            // determine if a build is running or not
            if ( build.getResult().equals(null) ) {
              jobName = build.parent.parent.name
              isRunning = true
            }
          }
          if ( isRunning ) {
            upstream_running = true
          }
        }
      }
    }
  }
  // Skip build when upstream detected
  if (upstream_running != null) {
    println 'Skipping build because upstream job detected (' + jobName + ')'
    //currentBuild.result = 'SUCCESS'
    //currentBuild.getRawBuild().getExecutor().interrupt(Result.SUCCESS)
    //sleep time: 1000, unit: 'MILLISECONDS' // Interrupt is not blocking and does not take effect immediately.
  }

  // Skip build when last commit is CI commit
  // returnStatus = 1 when string not found -> Team commit
  // returnStatus = 0 when string is found  -> CI commit
  def last_commit_is_team = sh(
    script: 'git log -1 | grep "\\[Jenkins CI\\]"',
    returnStatus: true
  )
  if (last_commit_is_team == 0) {
    println 'Skipping build because last commit has been done by CI'
    switchEmailNotif(false)
    //currentBuild.result = 'SUCCESS'
    //currentBuild.getRawBuild().getExecutor().interrupt(Result.SUCCESS)
    //sleep time: 1000, unit: 'MILLISECONDS' // Interrupt is not blocking and does not take effect immediately.
  } else {
    env.DONT_SKIP_JOB = "1"
    switchEmailNotif(true)
    println "Job started after a team commit detection, proceeding"
  }
  def isStartedByUser = currentBuild.rawBuild.getCause(hudson.model.Cause$UserIdCause) != null
  if (isStartedByUser) {
    env.DONT_SKIP_JOB = "1"
    switchEmailNotif(true)
    println "Job started by User, proceeding"
  }
  def isStartedByUpstream = currentBuild.rawBuild.getCause(hudson.model.Cause$UpstreamCause) != null
  if (isStartedByUpstream) {
    env.DONT_SKIP_JOB = "1"
    switchEmailNotif(true)
    println "Job started by Upstream, proceeding"
  }
}
