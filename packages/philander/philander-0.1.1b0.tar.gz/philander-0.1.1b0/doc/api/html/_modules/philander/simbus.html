
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>philander.simbus &#8212; philander 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for philander.simbus</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Serial bus simulation module to support debugging and cross-platform development.</span>

<span class="sd">This module provides a fake serial bus implementation to virtualize serial</span>
<span class="sd">communication. </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Oliver Maye&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1&quot;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SimBus&quot;</span><span class="p">,</span> <span class="s2">&quot;SimBusNull&quot;</span><span class="p">,</span> <span class="s2">&quot;SimBusMemory&quot;</span><span class="p">,</span> <span class="s2">&quot;MemoryType&quot;</span><span class="p">,</span> <span class="s2">&quot;Register&quot;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">module</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">dataclasses</span>
<span class="kn">import</span> <span class="nn">systypes</span>

<div class="viewcode-block" id="SimBus"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus">[docs]</a><span class="k">class</span> <span class="nc">SimBus</span><span class="p">(</span> <span class="n">module</span><span class="o">.</span><span class="n">Module</span> <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class to define the functionality of a simulated serial bus.</span>
<span class="sd">    </span>
<span class="sd">    A sub class must overwrite at least the methods for reading and writing</span>
<span class="sd">    a single byte. Implementation should use as least as possible dependencies</span>
<span class="sd">    to other modules. Use of hardware-dependent drivers must be completely</span>
<span class="sd">    avoided!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="SimBus.readRegByte"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.readRegByte">[docs]</a>    <span class="k">def</span> <span class="nf">readRegByte</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a single byte from a certain register.\</span>
<span class="sd">        A sub-class must overwrite this method.</span>
<span class="sd">        </span>
<span class="sd">        The method is expected to deliver a register&#39;s content to the</span>
<span class="sd">        caller.</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the register to be read.</span>
<span class="sd">        :returns: The value stored by the given register.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SimBus.writeRegByte"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.writeRegByte">[docs]</a>    <span class="k">def</span> <span class="nf">writeRegByte</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a single byte value into a certain register.\</span>
<span class="sd">        A sub-class must overwrite this method.</span>
<span class="sd">        </span>
<span class="sd">        The method is expected to store the given value to a register.</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the register to receive the new value.</span>
<span class="sd">        :param int data: The new value to store to that register.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SimBus.readRegWord"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.readRegWord">[docs]</a>    <span class="k">def</span> <span class="nf">readRegWord</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a word from a certain register.</span>
<span class="sd">        </span>
<span class="sd">        The word is formed from the content of the given register (low)</span>
<span class="sd">        and the content of the immediate successor ``aReg+1`` of that</span>
<span class="sd">        register (high).</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the low-byte register to be read.</span>
<span class="sd">        :returns: The value stored by the given register.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readRegByte</span><span class="p">(</span><span class="n">aReg</span><span class="p">)</span>
        <span class="n">hi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readRegByte</span><span class="p">(</span><span class="n">aReg</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">lo</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimBus.writeRegWord"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.writeRegWord">[docs]</a>    <span class="k">def</span> <span class="nf">writeRegWord</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a double-byte (word) value into a certain register.</span>
<span class="sd">        </span>
<span class="sd">        The method is expected to store the given value to a pair of</span>
<span class="sd">        registers. The low-part of the data item is stored at the given</span>
<span class="sd">        register, while the high-part is put at ``aReg+1``.</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the (low-) register to receive\</span>
<span class="sd">        the low-part of the new value.</span>
<span class="sd">        :param int data: The new value to store to that pair of registers.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bVal</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeRegByte</span><span class="p">(</span><span class="n">aReg</span><span class="p">,</span> <span class="n">bVal</span><span class="p">)</span>
        <span class="n">bVal</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeRegByte</span><span class="p">(</span><span class="n">aReg</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bVal</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SimBus.readRegDWord"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.readRegDWord">[docs]</a>    <span class="k">def</span> <span class="nf">readRegDWord</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a double word from a certain register.</span>
<span class="sd">        </span>
<span class="sd">        The dword is formed from the content of the four registers,</span>
<span class="sd">        starting with the given address ``aReg`` (low-byte of the low-word)</span>
<span class="sd">        and its successors ``aReg+1`` (high-byte of the low-word),</span>
<span class="sd">        ``aReg+2`` (low-byte of the high-word) and</span>
<span class="sd">        ``aReg+3`` (high-byte of the high-word).</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the first (lowest-byte) register to be read.</span>
<span class="sd">        :returns: The value stored by the given register.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readRegWord</span><span class="p">(</span> <span class="n">aReg</span> <span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readRegWord</span><span class="p">(</span> <span class="n">aReg</span><span class="o">+</span><span class="mi">2</span> <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">H</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">L</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="SimBus.writeRegDWord"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.writeRegDWord">[docs]</a>    <span class="k">def</span> <span class="nf">writeRegDWord</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a double-word (four bytes) value into a certain register.</span>
<span class="sd">        </span>
<span class="sd">        The method is expected to store the given value to a quadruple of</span>
<span class="sd">        registers. The low-byte of the low word is stored at the given</span>
<span class="sd">        register ``aReg``. The high-byte of the low-word goes to ``aReg+1``.</span>
<span class="sd">        The low-part of the high-word is stored to ``aReg+2`` and the</span>
<span class="sd">        high-part of the high-word is put at ``aReg+3``.</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the first (lowest byte) register\</span>
<span class="sd">        to receive part of the new value.</span>
<span class="sd">        :param int data: The new value to store to that quadruple of registers.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span>
        <span class="n">H</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xFFFF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeRegWord</span><span class="p">(</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">L</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">writeRegWord</span><span class="p">(</span> <span class="n">aReg</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">H</span> <span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="SimBus.readRegBlock"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.readRegBlock">[docs]</a>    <span class="k">def</span> <span class="nf">readRegBlock</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">num</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a block of data starting from the given register.</span>
<span class="sd">        </span>
<span class="sd">        Starting with the given Register address, ``num`` bytes are</span>
<span class="sd">        read and returned.</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the first register to be read.</span>
<span class="sd">        :param int num: The number of bytes to read.</span>
<span class="sd">        :returns: A list of ``num`` byte values as read from the registers.</span>
<span class="sd">        :rtype: list of integers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readRegByte</span><span class="p">(</span><span class="n">aReg</span><span class="o">+</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="SimBus.writeRegBlock"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBus.writeRegBlock">[docs]</a>    <span class="k">def</span> <span class="nf">writeRegBlock</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a block of byte data into registers.</span>
<span class="sd">        </span>
<span class="sd">        The first byte - at index zero - is stored at the given register</span>
<span class="sd">        ``aReg``, the next byte - at index 1 - is stored at ``aReg+1``</span>
<span class="sd">        and so on. More formally::</span>
<span class="sd">            </span>
<span class="sd">            data[0] -&gt; aReg</span>
<span class="sd">            data[1] -&gt; aReg + 1</span>
<span class="sd">            ...</span>

<span class="sd">        The number of bytes written is determined implicitly by the length</span>
<span class="sd">        of the ``data`` list. </span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the first register to receive\</span>
<span class="sd">        the block of data.</span>
<span class="sd">        :param list data: List of bytes to be written. The length of the\</span>
<span class="sd">        list determines the number of bytes to werite. So, all values in\</span>
<span class="sd">        the list will be transferred to the device.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">writeRegByte</span><span class="p">(</span><span class="n">aReg</span><span class="o">+</span><span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="SimBusNull"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusNull">[docs]</a><span class="k">class</span> <span class="nc">SimBusNull</span><span class="p">(</span> <span class="n">SimBus</span> <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Slim line serial bus simulation. Reading retrieves always the same\</span>
<span class="sd">    constant value, while writing is simply ignored. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">DEFAULT_READING</span> <span class="o">=</span> <span class="mh">0x3A</span>
    
<div class="viewcode-block" id="SimBusNull.Params_init"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusNull.Params_init">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">Params_init</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">paramDict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize configuration parameters.</span>
<span class="sd">        </span>
<span class="sd">        Any supported option missed in the dictionary handed in, will be</span>
<span class="sd">        added upon return. Also see :meth:`.module.Module.Params_init`.</span>
<span class="sd">        The following options are supported.</span>
<span class="sd">        </span>
<span class="sd">        ==================    =======    ==========================</span>
<span class="sd">        Key                   Range      Default</span>
<span class="sd">        ==================    =======    ==========================</span>
<span class="sd">        SimBusNull.reading    integer    SimBusNull.DEFAULT_READING</span>
<span class="sd">        ==================    =======    ==========================</span>
<span class="sd">        </span>
<span class="sd">        :param dict(str, object) paramDict: Dictionary mapping option names to their respective values.</span>
<span class="sd">        :returns: none</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramDict</span><span class="p">[</span><span class="s2">&quot;SimBusNull.reading&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">paramDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SimBusNull.reading&quot;</span><span class="p">,</span> <span class="n">SimBusNull</span><span class="o">.</span><span class="n">DEFAULT_READING</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>
    
<div class="viewcode-block" id="SimBusNull.open"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusNull.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">paramDict</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Open the instance and prepare it for use.</span>
<span class="sd">        </span>
<span class="sd">        Also see :meth:`.module.Module.open`.</span>
<span class="sd">        </span>
<span class="sd">        :param dict(str, object) paramDict: Configuration parameters as\</span>
<span class="sd">        obtained from :meth:`Params_init`, possibly.</span>
<span class="sd">        :return: An error code indicating either success or the reason of failure.</span>
<span class="sd">        :rtype: ErrorCode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paramDict</span><span class="p">[</span><span class="s2">&quot;SimBusNull.reading&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">paramDict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SimBusNull.reading&quot;</span><span class="p">,</span> <span class="n">SimBusNull</span><span class="o">.</span><span class="n">DEFAULT_READING</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reading</span> <span class="o">=</span> <span class="n">paramDict</span><span class="p">[</span><span class="s2">&quot;SimBusNull.reading&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">systypes</span><span class="o">.</span><span class="n">ErrorCode</span><span class="o">.</span><span class="n">errOk</span></div>
            
<div class="viewcode-block" id="SimBusNull.readRegByte"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusNull.readRegByte">[docs]</a>    <span class="k">def</span> <span class="nf">readRegByte</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read a single byte.</span>
<span class="sd">        </span>
<span class="sd">        Independent of the given register, the delivered value will</span>
<span class="sd">        always be the same. That delivered reading can be configured</span>
<span class="sd">        using the SimBusNull.reading option when calling :meth:`open`.</span>

<span class="sd">        :param int aReg: The address of the register to be read.\</span>
<span class="sd">        Actually ignored.</span>
<span class="sd">        :returns: The value stored by the given register.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="n">aReg</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reading</span></div>

<div class="viewcode-block" id="SimBusNull.writeRegByte"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusNull.writeRegByte">[docs]</a>    <span class="k">def</span> <span class="nf">writeRegByte</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Write a single byte.</span>

<span class="sd">        Actually, does nothing. Also see :meth:`SimBus.writeRegByte`.</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the register. Ignored.</span>
<span class="sd">        :param int data: The new value to store to that register. Ignored.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>
    


<div class="viewcode-block" id="MemoryType"><a class="viewcode-back" href="../../philander.html#philander.simbus.MemoryType">[docs]</a><span class="nd">@enum</span><span class="o">.</span><span class="n">unique</span>
<span class="k">class</span> <span class="nc">MemoryType</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumeration to reflect the different types of memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ROM</span>   <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">RAM</span>   <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">NVM</span>   <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">VOLATILE</span>  <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="Register"><a class="viewcode-back" href="../../philander.html#philander.simbus.Register">[docs]</a><span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Register</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate a memory-based register. Depending on the type of memory,\</span>
<span class="sd">    the register content can or cannot be changed by simply writing to it.\</span>
<span class="sd">    Volatile registers may change their content spontaneously or by\</span>
<span class="sd">    mechanisms that cannot be controlled by the user. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">address</span><span class="p">:</span>    <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The address to identify this register during read/write operations.&quot;&quot;&quot;</span>
    <span class="n">content</span><span class="p">:</span>    <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The register content. Can be initialized, independently of the\</span>
<span class="sd">    memory type of that register.&quot;&quot;&quot;</span>
    <span class="nb">type</span><span class="p">:</span>       <span class="n">MemoryType</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The type of memory for that register.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adr</span><span class="p">,</span> <span class="n">cont</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">MemoryType</span><span class="o">.</span><span class="n">RAM</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">adr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">cont</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">typ</span></div>


    
<div class="viewcode-block" id="SimBusMemory"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusMemory">[docs]</a><span class="k">class</span> <span class="nc">SimBusMemory</span><span class="p">(</span> <span class="n">SimBus</span> <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Serial bus implementation to simulate a device that can be accessed\</span>
<span class="sd">    through a set of memory-based registers. The list of registers\</span>
<span class="sd">    must be provided during instantiation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_regs</span> <span class="o">=</span> <span class="n">regs</span>
        
    <span class="k">def</span> <span class="nf">_findReg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regAdr</span><span class="p">):</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span> <span class="p">(</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regs</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">address</span><span class="o">==</span><span class="n">regAdr</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reg</span>
    
<div class="viewcode-block" id="SimBusMemory.open"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusMemory.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">paramDict</span> <span class="p">):</span>
        <span class="k">del</span> <span class="n">paramDict</span>
        <span class="k">return</span> <span class="n">systypes</span><span class="o">.</span><span class="n">ErrorCode</span><span class="o">.</span><span class="n">errOk</span></div>
            
<div class="viewcode-block" id="SimBusMemory.readRegByte"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusMemory.readRegByte">[docs]</a>    <span class="k">def</span> <span class="nf">readRegByte</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves a register&#39;s content. To also simulate side effects\</span>
<span class="sd">        of reading, the following steps are executed in sequence, no</span>
<span class="sd">        matter what the memory type of the given register is:</span>
<span class="sd">        </span>
<span class="sd">        #. calling :meth:`._onPreRead`</span>
<span class="sd">        #. reading the register content</span>
<span class="sd">        #. calling :meth:`._onPostRead`</span>
<span class="sd">        </span>
<span class="sd">        Note that the return value is solely determined by what is read</span>
<span class="sd">        from the register in step #2. It cannot be altered by :meth:`._onPostRead`,</span>
<span class="sd">        anymore.</span>

<span class="sd">        Also see :meth:`.simbus.SimBus.readRegByte`.</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the register to be read.</span>
<span class="sd">        :returns: The value stored by the given register.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findReg</span><span class="p">(</span> <span class="n">aReg</span> <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_onPreRead</span><span class="p">(</span> <span class="n">reg</span> <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">content</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_onPostRead</span><span class="p">(</span> <span class="n">reg</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="SimBusMemory.writeRegByte"><a class="viewcode-back" href="../../philander.html#philander.simbus.SimBusMemory.writeRegByte">[docs]</a>    <span class="k">def</span> <span class="nf">writeRegByte</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aReg</span><span class="p">,</span> <span class="n">data</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write a single byte value into a certain register.\</span>
<span class="sd">        Write attempts to registers with non-writable memory are ignored.\</span>
<span class="sd">        For registers with writable memory, the following sequence is\</span>
<span class="sd">        executed in order to give sub-classes the opportunity to simulate\</span>
<span class="sd">        side effects:</span>
<span class="sd">        </span>
<span class="sd">        #. calling :meth:`._onPreWrite`, may alter the intended data and\</span>
<span class="sd">        returns the actual new content.</span>
<span class="sd">        #. writing the new register content</span>
<span class="sd">        #. calling :meth:`._onPostWrite`</span>
<span class="sd">        </span>
<span class="sd">        :param int aReg: The address of the register to receive the new value.</span>
<span class="sd">        :param int data: The new value to store to that register.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findReg</span><span class="p">(</span> <span class="n">aReg</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">reg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">MemoryType</span><span class="o">.</span><span class="n">RAM</span><span class="p">):</span>
                <span class="n">newContent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onPreWrite</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="n">reg</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">newContent</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_onPostWrite</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_onPreRead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interface function that will be called right before a register\</span>
<span class="sd">        is read. Can be used by sub-classes to simulate the exact\</span>
<span class="sd">        hardware behavior while reading a register. Modifying the</span>
<span class="sd">        register content here, would highly affect the return value</span>
<span class="sd">        of the surrounding :meth:`.readRegByte` function.</span>
<span class="sd">        </span>
<span class="sd">        The current implementation is simply empty.</span>

<span class="sd">        :param Register reg: The register instance to be read.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">_onPostRead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interface function that will be called right after a register\</span>
<span class="sd">        was read. Can be used by sub-classes to simulate the exact\</span>
<span class="sd">        hardware behavior while reading a register.</span>
<span class="sd">        Any action in this routine will not influence the return value</span>
<span class="sd">        of the (current call of the) surrounding :meth:`.readRegByte`</span>
<span class="sd">        function.</span>
<span class="sd">        </span>
<span class="sd">        The current implementation increments the register content if</span>
<span class="sd">        the register&#39;s memory type is :attr:`MemoryType.VOLATILE`.</span>

<span class="sd">        :param Register reg: The register instance to be read.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">MemoryType</span><span class="o">.</span><span class="n">VOLATILE</span><span class="p">):</span>
            <span class="n">reg</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">content</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="k">def</span> <span class="nf">_onPreWrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">newData</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interface function that will be called right before a register\</span>
<span class="sd">        is written. Can be used by sub-classes to simulate the exact\</span>
<span class="sd">        hardware behavior while writing a register. The return value\</span>
<span class="sd">        immediately defines the actual content to be written. </span>
<span class="sd">        </span>
<span class="sd">        The current implementation just returns the `newData` argument.</span>

<span class="sd">        :param Register reg: The register instance to write to.</span>
<span class="sd">        :param int newData: The new value that is intended to be stored\</span>
<span class="sd">        to that register.</span>
<span class="sd">        :returns: The value that will actually be stored to the register.\</span>
<span class="sd">        Possibly a modified variant of the `newData` parameter.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="n">reg</span>
        <span class="k">return</span> <span class="n">newData</span>
    
    <span class="k">def</span> <span class="nf">_onPostWrite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interface function that will be called right after a register\</span>
<span class="sd">        was written. Can be used by sub-classes to simulate the exact\</span>
<span class="sd">        hardware behavior while writing a register.</span>
<span class="sd">        </span>
<span class="sd">        The current implementation is simply empty.</span>

<span class="sd">        :param Register reg: The register instance that was written.</span>
<span class="sd">        :returns: None</span>
<span class="sd">        :rtype: none</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
    
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">philander</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">philander</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Oliver Maye.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>